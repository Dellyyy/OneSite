<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Как я провел лето</title>
    <link rel="icon" type="image/x-icon" href="sun_siteicon.ico">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Courier New', monospace;
            background: url('background_dark.jpg') center/cover fixed;
            min-height: 100vh;
            color: #f0f0f0;
            transition: background 0.5s ease-in-out;
        }

        body.light-theme {
            background: url('background_light.jpg') center/cover fixed;
        }

        .container {
            display: grid;
            grid-template-columns: 250px 1fr;
            gap: 30px;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        /* Левое меню - изменен цвет на серый */
        .left-sidebar {
            background: rgba(80, 80, 80, 0.9);
            border: 2px solid #a0a0a0;
            border-radius: 15px;
            padding: 20px;
            height: fit-content;
            box-shadow: 0 0 20px rgba(160, 160, 160, 0.2);
            backdrop-filter: blur(10px);
            position: sticky;
            top: 20px;
        }

        .side-menu {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .side-btn {
            background: linear-gradient(135deg, #606060 0%, #1a1a1a 100%);
            border: 2px solid #a0a0a0;
            border-radius: 8px;
            padding: 15px 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            color: #f0f0f0;
            font-size: 1em;
            font-weight: bolder;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-align: center;
        }

        .side-btn.main-btn {
            background: linear-gradient(135deg, #7c7c7c 0%, #616161 100%);
        }

        .side-btn:hover {
            background: linear-gradient(135deg, #707070 0%, #606060 100%);
            transform: translateX(5px);
            box-shadow: 0 0 15px rgba(160, 160, 160, 0.3);
        }

        .side-btn.main-btn:hover {
            background: linear-gradient(135deg, #b0b0b0 0%, #909090 100%);
        }

        /* Кнопки мини-игр - теперь в ряд */
        .games-container {
            margin-top: 30px;
            display: flex;
            flex-direction: row;
            gap: 20px;
            justify-content: center;
            align-items: center;
        }

        .game-btn {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            border: 2px solid #a0a0a0;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 2em;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.4);
        }

        .game-btn.aimlabs {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .game-btn:hover {
            transform: scale(1.1);
        }

        .game-label {
            font-size: 0.8em;
            color: #c8c8c8;
            text-align: center;
            margin-top: 5px;
        }

        /* Контролы громкости */
        .volume-controls {
            margin-top: 20px;
            padding: 15px;
            background: rgba(70, 70, 70, 0.6);
            border-radius: 10px;
            border: 1px solid #a0a0a0;
        }

        .volume-control {
            margin-bottom: 10px;
        }

        .volume-control:last-child {
            margin-bottom: 0;
        }

        .volume-label {
            display: block;
            margin-bottom: 5px;
            color: #d0d0d0;
            font-size: 0.9em;
        }

        .volume-slider {
            width: 100%;
            height: 8px;
            -webkit-appearance: none;
            appearance: none;
            background: #505050;
            outline: none;
            border-radius: 4px;
        }

        .volume-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #a0a0a0;
            cursor: pointer;
        }

        /* Основной контент */
        .main-content {
            display: flex;
            flex-direction: column;
            gap: 30px;
        }

        .logo-container {
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            padding: 30px;
            background: rgba(80, 80, 80, 0.8);
            border: 2px solid #a0a0a0;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            min-height: 120px;
            position: relative;
        }

        .logo-text {
            font-size: 2.8em;
            color: #f0f0f0;
            text-shadow: 0 0 10px rgba(240, 240, 240, 0.5);
            margin: 0 auto;
        }

        .logo-image {
            position: absolute;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            cursor: pointer;
            z-index: 10;
        }

        .logo-image img {
            width: 80px;
            height: 80px;
            object-fit: contain;
            transition: transform 0.3s ease;
        }

        .logo-image:hover img {
            transform: scale(1.1);
        }

        .page {
            display: none;
            padding: 40px;
            background: rgba(80, 80, 80, 0.8);
            border: 2px solid #a0a0a0;
            border-radius: 15px;
            backdrop-filter: blur(10px);
            min-height: 400px;
        }

        .page h2 {
            margin-bottom: 25px;
            text-align: center;
            font-size: 2.2em;
            color: #f0f0f0;
            border-bottom: 2px solid #a0a0a0;
            padding-bottom: 15px;
        }

        /* Стили для вкладки Игры */
        .games-section-title {
            text-align: center;
            font-size: 1.8em;
            color: #f0f0f0;
            margin-bottom: 30px;
            padding: 10px;
            background: rgba(70, 70, 70, 0.6);
            border-radius: 10px;
            border: 1px solid #a0a0a0;
        }

        .games-grid {
            display: flex;
            justify-content: space-between;
            gap: 20px;
            margin-bottom: 40px;
        }

        .game-tile {
            flex: 1;
            background: rgba(70, 70, 70, 0.7);
            border: 2px solid #a0a0a0;
            border-radius: 12px;
            padding: 15px;
            min-height: 300px;
            display: flex;
            flex-direction: column;
            transition: transform 0.3s ease;
        }

        .game-tile:hover {
            transform: translateY(-5px);
            box-shadow: 0 5px 15px rgba(160, 160, 160, 0.2);
        }

        .game-image {
            width: 100%;
            height: 150px;
            background-color: #505050;
            border-radius: 8px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 3em;
            color: #a0a0a0;
            overflow: hidden;
        }

        .game-image img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .game-title {
            font-size: 1.3em;
            font-weight: bold;
            color: #f0f0f0;
            margin-bottom: 10px;
            text-align: center;
        }

        .game-description {
            color: #d0d0d0;
            font-size: 0.9em;
            line-height: 1.4;
            flex-grow: 1;
        }

        .other-games {
            background: rgba(70, 70, 70, 0.6);
            padding: 20px;
            border-radius: 10px;
            border: 1px solid #a0a0a0;
        }

        .other-games h3 {
            color: #f0f0f0;
            margin-bottom: 15px;
            text-align: center;
        }

        .other-games p {
            color: #d0d0d0;
            line-height: 1.6;
        }

        /* Модальные окна - изменен цвет на серый */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: rgba(80, 80, 80, 0.95);
            border: 3px solid #a0a0a0;
            border-radius: 15px;
            padding: 30px;
            text-align: center;
            max-width: 500px;
            box-shadow: 0 0 30px rgba(160, 160, 160, 0.3);
        }

        .modal h3 {
            color: #f0f0f0;
            margin-bottom: 20px;
        }

        .modal-btn {
            background: linear-gradient(135deg, #606060 0%, #505050 100%);
            border: 2px solid #a0a0a0;
            border-radius: 8px;
            padding: 12px 25px;
            color: #f0f0f0;
            cursor: pointer;
            margin: 10px 5px;
            transition: all 0.2s ease;
        }

        .modal-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(160, 160, 160, 0.3);
        }

        /* Рулетка - изменен цвет на серый */
        .roulette-game {
            background: rgba(80, 80, 80, 0.95);
            border: 3px solid #a0a0a0;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            width: 600px;
            max-width: 90vw;
        }

        .game-info {
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .balance {
            font-weight: bold;
            color: #2ecc71;
        }

        .bet-controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }

        .bet-amount {
            font-size: 1.2em;
            font-weight: bold;
            color: #f39c12;
        }

        .bet-btn {
            background: linear-gradient(135deg, #606060 0%, #505050 100%);
            border: 2px solid #a0a0a0;
            border-radius: 6px;
            padding: 8px 12px;
            color: #f0f0f0;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .bet-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 0 8px rgba(160, 160, 160, 0.3);
        }

        .betting-area {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 20px 0;
        }

        .bet-field {
            width: 120px;
            height: 120px;
            border: 3px solid #a0a0a0;
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .bet-field.red {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .bet-field.black {
            background: linear-gradient(135deg, #505050 0%, #000000 100%);
            color: white;
        }

        .bet-field.selected {
            box-shadow: 0 0 20px rgba(247, 220, 111, 0.8);
            border-color: #f7dc6f;
        }

        .bet-field:hover {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(160, 160, 160, 0.4);
        }

        .spin-btn {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            border: 2px solid #a0a0a0;
            border-radius: 8px;
            padding: 12px 30px;
            color: #f0f0f0;
            cursor: pointer;
            font-weight: bold;
            margin: 15px 0;
            transition: all 0.2s ease;
        }

        .spin-btn:hover:not(:disabled) {
            transform: scale(1.05);
            box-shadow: 0 0 15px rgba(46, 204, 113, 0.4);
        }

        .result-display {
            margin: 15px 0;
            padding: 12px;
            background: rgba(96, 96, 96, 0.5);
            border-radius: 8px;
            border: 2px solid #a0a0a0;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .result-text {
            font-size: 1.1em;
            font-weight: bold;
            text-align: center;
        }

        .win { color: #2ecc71; }
        .lose { color: #e74c3c; }

        .money-maker {
            margin-top: 15px;
            padding: 10px;
            background: rgba(96, 96, 96, 0.5);
            border-radius: 8px;
            border: 2px solid #a0a0a0;
        }

        .dodep-btn {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            border: 2px solid #a0a0a0;
            border-radius: 6px;
            padding: 8px 12px;
            color: #f0f0f0;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .dodep-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(243, 156, 18, 0.4);
        }

        /* AimLabs - изменен цвет на серый */
        .aim-game {
            background: rgba(80, 80, 80, 0.95);
            border: 3px solid #a0a0a0;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            width: 800px;
            max-width: 90vw;
        }

        .game-stats {
            display: flex;
            justify-content: space-around;
            margin-bottom: 20px;
            font-size: 1.2em;
        }

        .game-area {
            position: relative;
            width: 700px;
            height: 400px;
            background: rgba(96, 96, 96, 0.5);
            border: 2px solid #a0a0a0;
            border-radius: 10px;
            overflow: hidden;
            margin: 20px auto;
        }

        .target {
            position: absolute;
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, #e74c3c 0%, #c0392b 70%);
            border: 2px solid #a0a0a0;
            border-radius: 50%;
            cursor: pointer;
            transition: transform 0.1s ease;
        }

        .target:hover {
            transform: scale(1.1);
        }

        .crosshair {
            position: absolute;
            width: 20px;
            height: 20px;
            pointer-events: none;
            border: 2px solid #a0a0a0;
            border-radius: 50%;
            opacity: 0.7;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: #505050;
            border-radius: 5px;
            margin: 10px 0;
            overflow: hidden;
        }

        .progress {
            height: 100%;
            background: linear-gradient(90deg, #e74c3c 0%, #f39c12 100%);
            width: 0%;
            transition: width 0.3s ease;
        }

        .results {
            margin-top: 20px;
            padding: 15px;
            background: rgba(96, 96, 96, 0.5);
            border-radius: 10px;
            border: 2px solid #a0a0a0;
        }

        @keyframes glow {
            0%, 100% { text-shadow: 0 0 10px rgba(240, 240, 240, 0.3); }
            50% { text-shadow: 0 0 20px rgba(240, 240, 240, 0.6); }
        }

        .glow {
            animation: glow 3s ease-in-out infinite;
        }

        /* Секретная кнопка - ВСЕГДА становится видимой при наведении */
        .secret-button {
            position: fixed;
            width: 20px;
            height: 20px;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 9999;
            cursor: pointer;
        }

        .secret-button:hover {
            opacity: 1 !important; /* Важно: всегда показывать при наведении */
        }

        .secret-button img {
            width: 100%;
            height: 100%;
        }

        /* Темный фильтр - 75% затемнения */
        .dark-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            z-index: 10000;
            display: none;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .dark-overlay.active {
            opacity: 1;
        }

        /* Секретный текст */
        .secret-text {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            text-align: center;
            z-index: 10001;
            opacity: 0;
            transition: opacity 0.8s ease;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
        }

        .secret-text.visible {
            opacity: 1;
        }

        /* Секретный элемент 404 */
        .secret-404 {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            cursor: pointer;
            z-index: 999;
            transition: transform 0.3s ease;
        }

        .secret-404:hover {
            transform: scale(1.1);
        }

        .secret-404 img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        /* Ошибка 404 */
        .error-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            align-items: center;
            justify-content: center;
        }

        .error-content {
            background: rgba(80, 80, 80, 0.95);
            border: 3px solid #a0a0a0;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            max-width: 600px;
            box-shadow: 0 0 30px rgba(160, 160, 160, 0.3);
        }

        .error-404 {
            font-size: 6em;
            font-weight: bold;
            color: #e74c3c;
            margin-bottom: 20px;
            animation: bounce404 2s infinite;
        }

        @keyframes bounce404 {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }

        .error-text {
            color: #f0f0f0;
            font-size: 1.5em;
            margin-bottom: 30px;
        }

        .error-btn {
            background: linear-gradient(135deg, #606060 0%, #505050 100%);
            border: 2px solid #a0a0a0;
            border-radius: 8px;
            padding: 12px 25px;
            color: #f0f0f0;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
        }

        .error-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 10px rgba(160, 160, 160, 0.3);
        }
        .dark-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.75);
            z-index: 10000;
            display: none;
            opacity: 0;
            transition: opacity 1s ease;
            box-shadow: inset 0 0 100px rgba(0, 0, 0, 0.9); /* Внутренняя тень по краям */
        }

        /* Контейнер для секретных кнопок */
        .secret-buttons-container {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 10002;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 30px;
        }

        /* Стили для кнопок Да/Нет */
        .secret-buttons {
            display: flex;
            justify-content: center;
            gap: 40px;
        }

        .secret-btn {
            background: none;
            border: none;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 28px;
            cursor: pointer;
            padding: 15px 30px;
            transition: all 0.3s ease;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
        }

        .secret-btn:hover {
            transform: scale(1.1);
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }

        /* Делаем секретную кнопку видимой после 3 нажатий */
        .secret-button.visible {
            opacity: 1 !important;
        }

        .secret-button.visible:hover {
            opacity: 1 !important;
        }

        /* Новые стили для кнопок Да/Нет */
        .yes-no-container {
            position: fixed;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10003;
            display: flex;
            gap: 50px;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .yes-no-container.visible {
            opacity: 1;
        }

        .yes-no-button {
            background: none;
            border: none;
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 32px;
            cursor: pointer;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
            transition: all 0.3s ease;
            padding: 10px 20px;
        }

        .yes-no-button:hover {
            transform: scale(1.1);
            text-shadow: 0 0 15px rgba(255, 255, 255, 0.8);
        }
                .logo-container.darkened {
            background: rgba(40, 40, 40, 0.9);
            transition: background 0.5s ease;
        }

        .logo-text.darkened {
            color: #a0a0a0;
            text-shadow: 0 0 5px rgba(160, 160, 160, 0.3);
            transition: all 0.5s ease;
        }
        
        .music-player {
            margin-top: 20px;
            padding: 15px;
            background: rgba(70, 70, 70, 0.6);
            border-radius: 10px;
            border: 1px solid #a0a0a0;
        }

        .player-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .player-btn {
            background: linear-gradient(135deg, #606060 0%, #505050 100%);
            border: 2px solid #a0a0a0;
            border-radius: 6px;
            padding: 8px 12px;
            color: #f0f0f0;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .player-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 8px rgba(160, 160, 160, 0.3);
        }

        .track-info {
            text-align: center;
            color: #d0d0d0;
            font-size: 0.9em;
            margin-bottom: 10px;
            height: 20px;
        }

        /* Анимация тряски экрана */
        @keyframes screenShake {
            0%, 100% { transform: translateX(0) translateY(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-10px) translateY(-10px); }
            20%, 40%, 60%, 80% { transform: translateX(10px) translateY(10px); }
        }

        .screen-shake {
            animation: screenShake 0.5s ease-in-out;
        }

        /* Стили для заблокированного интерфейса */
        body.interface-locked .container {
            filter: brightness(0.7) contrast(0.9);
            transition: all 0.5s ease;
        }

        body.interface-locked .left-sidebar,
        body.interface-locked .main-content,
        body.interface-locked .page,
        body.interface-locked .logo-container,
        body.interface-locked .volume-controls {
            background: rgba(255, 0, 0, 0) !important;
            border-color: #666 !important;
        }

        /* Сохраняем скругленные углы для всех элементов */
        body.interface-locked .left-sidebar {
            border-radius: 15px !important;
        }

        body.interface-locked .main-content > * {
            border-radius: 15px !important;
        }

        body.interface-locked .page {
            border-radius: 15px !important;
        }

        body.interface-locked .logo-container {
            border-radius: 15px !important;
        }

        body.interface-locked .volume-controls {
            border-radius: 10px !important;
        }

        body.interface-locked .side-btn,
        body.interface-locked .game-btn,
        body.interface-locked .player-btn {
            background: linear-gradient(135deg, #454545 0%, #353535 100%) !important;
            border-color: #777 !important;
            color: #999 !important;
            border-radius: 8px !important;
        }

        body.interface-locked .side-btn {
            border-radius: 8px !important;
        }

        body.interface-locked .game-btn {
            border-radius: 50% !important;
        }

        body.interface-locked .player-btn {
            border-radius: 6px !important;
        }

        body.interface-locked .logo-text {
            color: #999 !important;
            text-shadow: 0 0 3px rgba(153, 153, 153, 0.2) !important;
        }

        body.interface-locked .volume-label {
            color: #999 !important;
        }

        body.interface-locked .volume-slider {
            background: #454545 !important;
            border-radius: 4px !important;
        }

        body.interface-locked .volume-slider::-webkit-slider-thumb {
            background: #777 !important;
            border-radius: 50% !important;
        }

        /* Убираем общее затемнение экрана */
        body.interface-locked::before {
            display: none;
        }

        body.interface-locked .side-btn,
        body.interface-locked .game-btn,
        body.interface-locked .secret-404,
        body.interface-locked .player-btn {
            pointer-events: none;
            opacity: 0.5;
            cursor: not-allowed;
        }

        body.interface-locked .music-player {
            opacity: 0.7;
            border-radius: 10px !important;
        }

        body.interface-locked .music-player::after {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: #e74c3c;
            text-shadow: 0 0 10px rgba(231, 76, 60, 0.5);
        }

        /* Стили для системного сообщения повреждения */
        .system-damage-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.507);
            z-index: 10010;
            display: none; /* Добавьте это */
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity 1s ease;
        }

        .system-damage-overlay.active {
            opacity: 1;
            cursor: pointer; /* Добавляем курсор-указатель */
        }

        .system-damage-text {
            color: white;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            text-align: center;
            opacity: 0;
            transition: opacity 1s ease;
            text-shadow: 2px 2px 0 #000, -2px -2px 0 #000, 2px -2px 0 #000, -2px 2px 0 #000;
        }

        .system-damage-text.visible {
            opacity: 1;
        }

        /* Скрываем оригинальную секретную кнопку в сломанном режиме */
        body.interface-locked .secret-button {
            display: none;
        }

        /* Новая кнопка для сломанного режима */
        .broken-clover {
            position: fixed;
            width: 20px;
            height: 20px;
            cursor: pointer;
            z-index: 9999;
            transition: transform 0.3s ease;
            display: none; /* Добавьте это */
        }

        .broken-clover:hover {
            transform: scale(1.1);
        }
        

        .broken-clover img {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }

        body.interface-locked .broken-clover {
            display: block;
        }

        /* Стили для измененного текста после поломки */
        .logo-text.broken {
            color: #e74c3c !important;
            text-shadow: 0 0 10px rgba(231, 76, 60, 0.5) !important;
            animation: glitch 0.5s infinite;
        }

        @keyframes glitch {
            0% { text-shadow: 0 0 10px rgba(231, 76, 60, 0.5); }
            50% { text-shadow: 0 0 15px rgba(231, 76, 60, 0.8); }
            100% { text-shadow: 0 0 10px rgba(231, 76, 60, 0.5); }
        }

        .logo-text.broken {
            color: #e74c3c !important;
            text-shadow: 0 0 10px rgba(231, 76, 60, 0.5) !important;
            animation: glitch 2s infinite;
        }

        .hidden-content {
            display: none !important;
        }

        .side-btn {
            transition: all 0.4s ease; /* Убедитесь что это свойство есть */
        }

        /* PixelPaint - стили как у других игр */
        .pixel-game {
            background: rgba(80, 80, 80, 0.95);
            border: 3px solid #a0a0a0;
            border-radius: 15px;
            padding: 20px;
            text-align: center;
            width: 1000px;
            max-width: 95vw;
            height: 600px;
            display: flex;
            flex-direction: row;
            gap: 20px;
        }

        .pixel-controls-panel {
            width: 250px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            overflow-y: auto;
            max-height: 100%;
            padding-right: 10px;
        }

        .pixel-controls-panel::-webkit-scrollbar {
            width: 8px;
        }

        .pixel-controls-panel::-webkit-scrollbar-track {
            background: #505050;
            border-radius: 4px;
        }

        .pixel-controls-panel::-webkit-scrollbar-thumb {
            background: #a0a0a0;
            border-radius: 4px;
        }

        .pixel-canvas-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }


        .pixel-btn {
            background: linear-gradient(135deg, #606060 0%, #505050 100%);
            border: 2px solid #a0a0a0;
            border-radius: 6px;
            padding: 8px 12px;
            color: #f0f0f0;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9em;
        }

        .pixel-btn-clear {
            background: linear-gradient(135deg, #5f0707 0%, #ff0505 100%);
            border: 2px solid #a0a0a0;
            border-radius: 6px;
            padding: 8px 12px;
            color: #f0f0f0;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9em;
        }

        .pixel-btn-clear:hover {
            box-shadow: 0 0 8px rgba(255, 73, 73, 0.568);
            background: linear-gradient(135deg, #5f0707 0%, #ff0505 100%);
        }

        .pixel-btn:hover {
            box-shadow: 0 0 8px rgba(160, 160, 160, 0.3);
            background: linear-gradient(135deg, #707070 0%, #606060 100%);
        }

        .color-palette {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin: 10px 0;
            justify-content: center;
        }

        .color-item {
            width: 30px;
            height: 30px;
            border: 2px solid #a0a0a0;
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .color-item:hover {
            transform: scale(1.1);
        }

        .color-item.selected {
            border-color: #f7dc6f;
            box-shadow: 0 0 10px rgba(247, 220, 111, 0.8);
        }

        .pixel-area {
            position: relative;
            width: 645px;
            height: 405px;
            background: #1a1a1a;
            border: 2px solid #a0a0a0;
            overflow: hidden;
            cursor: crosshair;
        }

        .pixel {
            position: absolute;
            width: 10px;
            height: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .pixel-grid {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: 
                linear-gradient(rgba(255,255,255,0.1) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255,255,255,0.1) 1px, transparent 1px);
            background-size: 10px 10px;
            pointer-events: none;
        }

        .canvas-tabs {
            display: flex;
            gap: 5px;
            margin: 10px 0;
            justify-content: center;
            flex-wrap: wrap;
        }

        .canvas-tab {
            background: linear-gradient(135deg, #606060 0%, #505050 100%);
            border: 1px solid #a0a0a0;
            border-radius: 4px;
            padding: 10px 30px 10px 15px; /* Добавляем место справа для кнопки */
            cursor: pointer;
            font-size: 0.9em;
            text-align: center;
            transition: all 0.2s ease;
            position: relative;
            min-height: 18px;
        }

        .canvas-tab.editing {
            background: linear-gradient(135deg, #7c7c7c 0%, #616161 100%);
            border-color: #f7dc6f;
            padding: 10px 15px; /* Убираем лишний padding при редактировании */
        }

        .rename-btn {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            color: #a0a0a0;
            cursor: pointer;
            font-size: 0.8em;
            padding: 2px 5px;
            opacity: 0;
            transition: opacity 0.2s ease;
            z-index: 2;
        }

        .canvas-tab:hover .rename-btn {
            opacity: 1;
        }

        .rename-btn:hover {
            color: #f7dc6f;
        }

        .rename-input {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid #f7dc6f;
            border-radius: 3px;
            color: #f0f0f0;
            font-size: 0.9em;
            padding: 2px 5px;
            width: 100%;
            text-align: center;
            font-family: 'Courier New', monospace;
            margin: -2px 0;
        }

        .rename-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.15);
        }

        .canvas-tab.active {
            background: linear-gradient(135deg, #7c7c7c 0%, #616161 100%);
            border-color: #f7dc6f;
        }

        .template-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.3;
        }

        /* Стиль для кнопки PixelPaint в games-container */
        .game-btn.pixelpaint {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
        }

        .color-picker-container {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }

        .color-preview {
            width: 30px;
            height: 30px;
            border: 2px solid #a0a0a0;
            border-radius: 4px;
            cursor: pointer;
        }

        .color-palette-input {
            display: none;
        }

        .template-controls {
            background: rgba(70, 70, 70, 0.6);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #a0a0a0;
            margin-top: 10px;
        }

        .template-slider {
            width: 100%;
            margin: 10px 0;
        }

        .template-movement {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-top: 10px;
        }

        .movement-buttons {
            display: grid;
            grid-template-areas: 
                ". up ."
                "left center right"
                ". down .";
            grid-template-columns: 1fr 1fr 1fr;
            gap: 5px;
            margin-top: 5px;
        }

        .movement-btn.up { grid-area: up; }
        .movement-btn.left { grid-area: left; }
        .movement-btn.center { grid-area: center; }
        .movement-btn.right { grid-area: right; }
        .movement-btn.down { grid-area: down; }

        .movement-btn {
            background: linear-gradient(135deg, #606060 0%, #505050 100%);
            border: 1px solid #a0a0a0;
            border-radius: 4px;
            padding: 8px;
            color: #f0f0f0;
            cursor: pointer;
            font-size: 0.9em;
            min-width: 40px;
        }

        .movement-btn:hover {
            background: linear-gradient(135deg, #707070 0%, #606060 100%);
        }

        /* Стили для панели инструментов */
        .tools-panel {
            background: rgba(70, 70, 70, 0.6);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #a0a0a0;
            margin-top: 10px;
        }

        .tool-btn {
            background: linear-gradient(135deg, #606060 0%, #505050 100%);
            border: 1px solid #a0a0a0;
            border-radius: 4px;
            padding: 8px 12px;
            color: #f0f0f0;
            cursor: pointer;
            font-size: 0.9em;
            margin: 2px;
            transition: all 0.2s ease;
            width: 100%;
            text-align: center;
        }

        .tool-btn.active {
            background: linear-gradient(135deg, #7c7c7c 0%, #616161 100%);
            border-color: #f7dc6f;
        }

        .tool-btn:hover {
            background: linear-gradient(135deg, #707070 0%, #606060 100%);
        }

        .tool-controls {
            margin-top: 10px;
            padding: 10px;
            background: rgb(29, 29, 29);
            border-radius: 5px;
            display: none;
        }

        .tool-controls.active {
            display: block;
        }

        .tool-label {
            color: #d0d0d0;
            font-size: 0.8em;
            margin-bottom: 5px;
        }

        .selection-controls {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .color-replace-controls {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .color-replace-controls > div {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .selection-area {
            position: absolute;
            border: 2px dashed #f7dc6f;
            background: rgba(247, 220, 111, 0.1);
            pointer-events: none;
            z-index: 10;
        }

        .pipette-mode {
            cursor: crosshair !important;
        }

        .pipette-mode .pixel {
            cursor: crosshair !important;
        }

        .color-replace-preview {
            width: 30px;
            height: 30px;
            border: 2px solid #a0a0a0;
            border-radius: 4px;
            flex-shrink: 0;
        }

        /* Стили для информационной панели инструментов */
        .tool-info-panel {
            background: rgba(70, 70, 70, 0.6);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid #a0a0a0;
            margin-top: 10px;
            width: 100%;
            max-width: 640px;
            text-align: center;
        }

        .selected-tool {
            color: #f7dc6f;
            font-weight: bold;
            font-size: 1em;
            margin-bottom: 8px;
        }

        .tool-description {
            color: #d0d0d0;
            font-size: 0.9em;
            line-height: 1.4;
        }

        /* Стили для кнопок undo/redo */
        .undo-redo-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }

        .undo-btn, .redo-btn {
            background: linear-gradient(135deg, #606060 0%, #505050 100%);
            border: 2px solid #a0a0a0;
            border-radius: 6px;
            padding: 8px 12px;
            color: #f0f0f0;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9em;
            flex: 1;
            text-align: center;
        }

        .undo-btn:hover, .redo-btn:hover {
            background: linear-gradient(135deg, #707070 0%, #606060 100%);
            box-shadow: 0 0 8px rgba(160, 160, 160, 0.3);
        }

        .undo-btn:disabled, .redo-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: linear-gradient(135deg, #454545 0%, #353535 100%);
        }

        /* Стили для недавних цветов */
        .recent-colors-container {
            margin: 15px 0;
        }

        .recent-colors-label {
            color: #d0d0d0;
            font-size: 0.9em;
            text-align: center;
            margin-bottom: 8px;
        }

        .recent-colors {
            display: flex;
            gap: 5px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .recent-color-item {
            width: 25px;
            height: 25px;
            border: 2px solid #a0a0a0;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .recent-color-item:hover {
            transform: scale(1.1);
            border-color: #f7dc6f;
        }

        .recent-color-item.empty {
            background: repeating-linear-gradient(
                45deg,
                #505050,
                #505050 2px,
                #606060 2px,
                #606060 4px
            );
            border-color: #666;
            cursor: default;
        }

        .recent-color-item.empty:hover {
            transform: none;
            border-color: #666;
        }

        /* Стили для чекбокса прозрачного фона */
        .transparent-bg-control {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 10px 0;
            padding: 8px;
            background: rgba(70, 70, 70, 0.6);
            border-radius: 6px;
            border: 1px solid #a0a0a0;
        }

        .transparent-checkbox {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #f7dc6f;
        }

        .transparent-label {
            color: #f0f0f0;
            font-size: 0.9em;
            cursor: pointer;
        }

        .transparent-label:hover {
            color: #f7dc6f;
        }

        /* Стили для кнопки отмены выделения */
        .deselect-btn {
            background: linear-gradient(135deg, #8B4513 0%, #A0522D 100%);
            border: 2px solid #a0a0a0;
            border-radius: 6px;
            padding: 8px 12px;
            color: #f0f0f0;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.9em;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            width: 100%;
            margin-top: 5px;
        }

        .deselect-btn:hover {
            background: linear-gradient(135deg, #A0522D 0%, #8B4513 100%);
            box-shadow: 0 0 8px rgba(160, 82, 45, 0.4);
        }

        .deselect-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            background: linear-gradient(135deg, #454545 0%, #353535 100%);
        }

    </style>
</head>
<body>
    <!-- Аудио элементы для звуков -->
    <audio id="hoverSound" preload="auto">
        <source src="cursor.wav" type="audio/mpeg">
    </audio>
    <audio id="clickSound" preload="auto">
        <source src="select.wav" type="audio/mpeg">
    </audio>
    <audio id="cancelSound" preload="auto">
        <source src="quit.wav" type="audio/mpeg">
    </audio>
    <!-- Новый звук для разбития стекла -->
    <audio id="glassSound" preload="auto">
        <source src="shatter.wav" type="audio/mpeg">
    </audio>

    <audio id="music1" preload="auto">
        <source src="IntoTheLight.ogg" type="audio/ogg">
    </audio>
    <audio id="music2" preload="auto">
        <source src="ChildrenOfTheRuins_piano.ogg" type="audio/ogg">
    </audio>
    <audio id="music3" preload="auto">
        <source src="OnLittleCatFeet.ogg" type="audio/ogg">
    </audio>
    <audio id="music4" preload="auto">
        <source src="ToSleep.ogg" type="audio/ogg">
    </audio>
    <audio id="music5" preload="auto">
        <source src="MyBurdenIsLight.ogg" type="audio/ogg">
    </audio>
    <audio id="music6" preload="auto">
        <source src="NikoAndTheWorldMachine.ogg" type="audio/ogg">
    </audio>
    <audio id="musicBroken" preload="auto">
        <source src="MyBurdenIsDead.ogg" type="audio/ogg">
    </audio>

    <!-- После существующих аудио элементов -->
    <audio id="paintSound" preload="auto">
        <source src="paint_pixel.mp3" type="audio/mpeg">
    </audio>
    <audio id="removeSound" preload="auto">
        <source src="remove_pixel.mp3" type="audio/mpeg">
    </audio>

    <div class="container">
        <!-- Левое меню -->
        <div class="left-sidebar">
            <div class="side-menu">
                <div class="side-btn main-btn" onclick="showPage('main'); playClickSound()">Главная</div>
                <div class="side-btn" onclick="showPage('trips'); playClickSound()" onmouseover="playHoverSound()">Поездки</div>
                <div class="side-btn" onclick="showPage('media'); playClickSound()" onmouseover="playHoverSound()">Фильмы, сериалы, аниме</div>
                <div class="side-btn" onclick="showPage('games'); playClickSound()" onmouseover="playHoverSound()">Игры</div>
                <div class="side-btn" onclick="showPage('it'); playClickSound()" onmouseover="playHoverSound()">IT-деятельность</div>
                <div class="side-btn" onclick="showPage('achievements'); playClickSound()" onmouseover="playHoverSound()">Похвастаться</div>
                <div class="side-btn" onclick="showPage('sufferings'); playClickSound()" onmouseover="playHoverSound()">Страдания</div>
            </div>
            
        <!-- Кнопки мини-игр - теперь в ряд -->
        <div class="games-container">
            <div>
                <div class="game-btn" onclick="showModal('rouletteGame'); playClickSound()" onmouseover="playHoverSound()">🎰</div>
                <div class="game-label">Рулетка</div>
            </div>
            <div>
                <div class="game-btn aimlabs" onclick="showModal('aimGame'); playClickSound()" onmouseover="playHoverSound()">🎯</div>
                <div class="game-label">AimLabs</div>
            </div>
            <div>
                <div class="game-btn pixelpaint" onclick="showModal('pixelGame'); playClickSound()" onmouseover="playHoverSound()">🎨</div>
                <div class="game-label">PixelPaint</div>
            </div>
        </div>
            
            <div class="music-player" id="musicPlayer">
                <div class="track-info" id="trackInfo">Музыка выключена</div>
                <div class="player-controls">
                    <button class="player-btn" onclick="prevTrack()" onmouseover="playHoverSound()">⏮</button>
                    <button class="player-btn" onclick="togglePlay()" onmouseover="playHoverSound()" id="playBtn">▶</button>
                    <button class="player-btn" onclick="nextTrack()" onmouseover="playHoverSound()">⏭</button>
                </div>
            </div>

            <!-- Контролы громкости -->
            <div class="volume-controls">
                <div class="volume-control">
                    <label class="volume-label">Громкость звуков</label>
                    <input type="range" class="volume-slider" id="sfxVolume" min="0" max="100" value="50" oninput="updateVolume()">
                </div>
                <div class="volume-control">
                    <label class="volume-label">Громкость музыки</label>
                    <input type="range" class="volume-slider" id="musicVolume" min="0" max="100" value="50" oninput="updateVolume()">
                </div>
            </div>
        </div>

        <!-- Основной контент -->
        <div class="main-content">
            <!-- Логотип -->
            <div class="logo-container">
                <div class="logo-image" onclick="toggleLamp()">
                    <img id="lampImage" src="sun_off.png" alt="Лето 2024">
                </div>
                <div class="logo-text glow">Как я провёл это лето</div>
            </div>

            <!-- Страницы -->
            <div id="main" class="page">
                <h2>Главная страница</h2>
                <div class="content">
                    <p style="font-size: 19px;">Добро пожаловать на мой сайт, на котором я расскажу о своих летних приключениях! Здесь вы найдете информацию о том, как я провел лето, 
                    мои увлечения и интересы, а также несколько интересных мини-игр, которые я создал специально для этого проекта.</p>
                    <p style="font-size: 19px;">Лето - это время открытий, путешествий и новых впечатлений. В этом году мне удалось посетить несколько интересных мест, 
                    научиться новым навыкам и просто хорошо отдохнуть. Подробнее об этом вы можете узнать в соответствующих разделах сайта.</p>
                    <p style="font-size: 19px;">Не забудьте настроить громкость звуков и музыки с помощью ползунков в левой панели, а также попробовать мини-игры, 
                    которые я подготовил. Приятного просмотра! <br><br><br><br><br><p style="font-size: 19px;">P.S.</p><br><p style="font-size: 19px;">Я нашёл доступ к секретному файлу. Для просмотра обратитесь к <strong>центральному терминалу</strong>. Найди <strong>Клевер</strong> в углу страницы и нажми на него. Терминал откроется спустя пару секунд.</p>
                </div>
            </div>

            <div id="trips" class="page">
                <h2>Мои летные поездки</h2>
                <div class="content">
                    <p style="font-size: 25px;">Этим летом я почти никуда не ездил. В основном — дорога на работу и обратно. Иногда выбирался на рыбалку: сидел с удочкой на берегу, никуда не торопился. А ещё были простые прогулки с друзьями по вечерам. Без планов, просто шли и разговаривали. Не было грандиозных путешествий, но в этой тихой и привычной простоте тоже был свой уют и свой маленький летний вайб.</p>
                </div>
            </div>

<div id="media" class="page">
    <h2>Просмотренное летом</h2>
    
    <div class="games-section-title">Просмотренное летом</div>
    
    <div class="games-grid">
        <div class="game-tile">
            <div class="game-image" style="position: relative; width: 100%; padding-top: 56.25%; overflow: hidden;">
                <img src="SquidGame3.jpg" alt="SG3" onerror="this.style.display='none'; this.parentElement.innerHTML='🎬';" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
            </div>
            <div class="game-title">Игра в Кальмара 3</div>
            <div class="game-description">
                В целом, эта дорама мне очень понравилась. Начиная различными сюжетными поворотами и заканчивая концовкой. Но со Второго сезона начались некоторые вопросы. Например, зачем нужно было растягивать сериал до третьего сезона? Зачем заканчивать второй сезон жирным многоточием? Вообщем такой поворот событий мне не очень понравился, но всеравно с нетерпеньем ждал третьего сезона. Во втором сезоне больше всего понравилась сцена с "Революцией" участников игры против её создателя. Более подробно расписать не получится, т.к. супер крутому интернет-провайдеру "Ростелекому" это не очень понравится.
                Если говорить про третий сезон, то больше всего понравилось то, что Главный Герой потерял смысл жизни, т.к. его план по "Остановке" игр провалился, но потом он все же обрел смысл продолжать играть, потому что поставил себе цель спасти младенца Игрока 222. Концовка для меня оказаламь очень грустной, но я считаю правильной.
                По итогу скажу, что сериал мне понравился, поставил бы ему 7.5/10.
            </div>
        </div>
        
        <div class="game-tile">
            <div class="game-image" style="position: relative; width: 100%; padding-top: 56.25%; overflow: hidden;">
                <img src="HTTYD.jpg" alt="HTTYD" onerror="this.style.display='none'; this.parentElement.innerHTML='🎬';" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover;">
            </div>
            <div class="game-title">Как приручить дракона в кино</div>
            <div class="game-description">
                Пару лет назад, я посмотрел мультфильм "Как приручить дракона". Мне этот мультфильм очень понравился, и он стал моим любимым. Тогда я даже подумать не мог, что спустя целых 15 лет, студия выпустит его фильм-версию. Но если говорить честно, то я не был им впечатлён. Мультфильм мне понравился больше, чем фильм, но нужно отдать должное, актеры подобраны хорошо, хоть и не везде. В целом я бы поставил ему 7/10.
            </div>
        </div>
    </div>
    
    <div class="other-games">
        <h3>Другие просмотры</h3>
        <p style="font-size: 20px;">Я не особый любитель смотреть фильмы, сериалы и уж тем более аниме, хотя я к этому нейтрально отношусь. В скором времени планирую посмотреть что-то еще.</p>
    </div>
</div>

            <div id="games" class="page">
                <h2>Летные игры</h2>
                <div class="games-section-title">Любимые игры</div>
                
                <div class="games-grid">
                    <div class="game-tile">
                        <div class="game-image">
                            <img src="cs2.jpg" alt="Cоunter-Strikе 2" onerror="this.style.display='none'; this.parentElement.innerHTML='🎮';">
                        </div>
                        <div class="game-title">Соuntеr-Strikе 2</div>
                        <div class="game-description">
                            Сколько можно сказать хорошего про нашу нерегающую контру? Я думаю... Пальцев одной руки будет достаточно. Игра неплохая, если в нее не играть. Что я в принципе и делал этим летом. В основном заходил раз в неделю, ведь именно по средам, я могу выбить себе супер-кейс за 26 рублей. Мда... Но зато у меня наигранно в ней 2000 часов(это мало кстати). Всё.
                        </div>
                    </div>
                    
                    <div class="game-tile">
                        <div class="game-image">
                            <img src="ONESHOT.jpg" alt="OneShot" onerror="this.style.display='none'; this.parentElement.innerHTML='🎮';">
                        </div>
                        <div class="game-title">OneShot</div>
                        <div class="game-description">
                            Эта игра вышла в 2016 года, но решил поиграть в нее только этим летом. Эта игра произвела на меня неимоверное впечатление, хотя по сути, это простая ходилка-собиралка в пиксельном стиле, но что-то в ней есть такое, что не заставит меня забыть о ней даже спустя 20 лет. Кстати спасибо этой игре за предоставление всех звуковых сопровождений на моём сайте :)
                        </div>
                    </div>
                    
                    <div class="game-tile">
                        <div class="game-image">
                            <img src="eft.jpg" alt="EFT" onerror="this.style.display='none'; this.parentElement.innerHTML='🎮';">
                        </div>
                        <div class="game-title">Escape From Tarkov</div>
                        <div class="game-description">
                            Рейд, схрон, потом опять рейд, голова-глаза от дикого, схрон, рейд... И так на протяжении 400 часов геймплея. Oружиe клинит, враги не умирают, а ты постоянно отлетаешь от одной тычки. Но несмотря на это, эта игра хороша, ведь кто-то должен закрывать квесты того самого Егеря. Плюсом, за это лето я наконец-то выполнил все квесты для подсумка Каппы, в который я могу положить больше налутанного добра, не боясь, что потеряю его. Вообщем игра имба, всем советую.
                        </div>
                    </div>
                </div>
                
                <div class="other-games">
                    <h3>Другие игры</h3>
                    <p style="font-size: 18px;"><strong>• Geometry Dash</strong> - простая 2D игра, в которой я наиграл 700 часов... Мда. Играю в неё со школы, а если быть точне, то со второго класса. Из-за нее мне пришлось менять экран на телефоне и покупать новый жесткий диск на ноутбук. Думаете я после этого перестал в нее играть? Конечно же нет.<br><br></p>
                    <p style="font-size: 18px;"><strong>• Minecraft</strong> - как же без него? Этим летом, на дне рождения Мамы, я напился и купил себе лицензионный ключ Майна за 1500 рублей :)<br><br></p>
                    <p>Вообще, у меня много игр, но обо всех писать нет смысла, да и играл я летом в них редко.</p>
                </div>
            </div>

            <div id="it" class="page">
                <h2>IT деятельность</h2>
                <div class="content">
                    <p style="font-size: 25px;">Летом меня пригласили на подработку в отдел рекламы гипермаркета. В этом отделе я, работая за компьютером, в программе <strong>Adobe Illustrator</strong> делал и печатал различные плакаты и ценники для магазина. Связано ли это с IT? Я не знаю. Но сказать мне больше нечего.</p>
                </div>
            </div>

            <div id="achievements" class="page">
                <h2>Похвастаться</h2>
                <div class="content">
                    <p style="font-size: 30px;"><strong>Вообще-то хвастаться не хорошо. Но так уж и быть...</strong><br><br></p>
                    <p style="font-size: 25px;">Из прошлого пункта, вы узнали, что я работал этим летом(круто да?), и с этой работы мне удалось неплохо так приподнять свой капитал.<br><br></p>
                    <p style="font-size: 25px;">Еще могу похвастаться тем, что я купил себе новый спиннинг для рыбалки.</p>
                </div>
            </div>

            <div id="sufferings" class="page">
                <h2>Летные трудности</h2>
                <div class="content">
                    <p style="font-size: 27px;"><strong>А кто сейчас не страдает?</strong><br><br></p>
                    <p style="font-size: 20px;">Лично я этим летом страдал только невыносимой жарой, особенно, когда идешь уставший с работы, а тебе еще предстоит ехать на электричке, в которой народу больше, чем в Китае.<br><br></p>
                    <p style="font-size: 20px;">Еще могу рассказать грустную, и одновременно жуткую историю о том, как мы на 3 дня потеряли нашего кота...<br> Вечером какого-то дня, мы не заметили, как наш кот сбежал из квартиры в подъезд. Заметили пропажу только утром на следующий день. Искали на протяжении двух суток, но безуспешно. Во второй день, мы с Мамой собрались проверить 3-4 подъезд нашего дома. И я, проходя мимо 3-го подъезда, слышу, как с грохотом что-то упало на землю. Подойдя поближе, чтобы рассмотреть, я понял, что это из окна выпрыгнул чей-то серый кот, не наш. Предположительно, с 9-го этажа. К сожалению... Кот скончался на месте... После всех этих событий я не мог нормально спать. Но на третий день, мы с мамой решили проверить наш подвал. Одев защитную экипировку, т.к. в подвале было очень много блох, и взяв фонарик, я отправился на поиски... И спустя минут 10, я нахожу его в дальней части подвала, в недоступном для меня месте. Приманив его кормом, потому что он очень пугливый, и не хотел идти ко мне, я взял его и потащил домой.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Мини-игра Рулетка -->
    <div id="rouletteGame" class="modal">
        <div class="roulette-game">
            <h3>🎰 Казино Рулетка 🎰</h3>
            
            <div class="game-info">
                <div>Баланс: <span class="balance" id="balance">200</span> ₽</div>
                <div>Ставка: <span class="bet-amount" id="betAmount">10</span> ₽</div>
            </div>

            <div class="bet-controls">
                <button class="bet-btn" onclick="changeBet(-10); playCancelSound()" onmouseover="playHoverSound()">-10</button>
                <button class="bet-btn" onclick="changeBet(-5); playCancelSound()" onmouseover="playHoverSound()">-5</button>
                <button class="bet-btn" onclick="changeBet(5); playClickSound()" onmouseover="playHoverSound()">+5</button>
                <button class="bet-btn" onclick="changeBet(10); playClickSound()" onmouseover="playHoverSound()">+10</button>
            </div>

            <div class="betting-area">
                <div class="bet-field red" onclick="selectColor('red'); playClickSound()" onmouseover="playHoverSound()">КРАСНОЕ</div>
                <div class="bet-field black" onclick="selectColor('black'); playClickSound()" onmouseover="playHoverSound()">ЧЁРНОЕ</div>
            </div>

            <button class="spin-btn" id="spinBtn" onclick="spinRoulette(); playClickSound()" onmouseover="playHoverSound()">Крутить</button>

            <div class="result-display">
                <div class="result-text" id="resultText">Сделайте ставку на цвет и крутите!</div>
            </div>

            <div class="money-maker">
                <h4>Заработать деньги:</h4>
                <button class="dodep-btn" onclick="makeMoney()" onmouseover="playHoverSound()">Додеп (+2 ₽)</button>
            </div>

            <div>
                <button class="modal-btn" onclick="hideModalWithSound('rouletteGame')" onmouseover="playHoverSound()">Выйти</button>
            </div>
        </div>
    </div>

    <!-- Мини-игра AimLabs -->
    <div id="aimGame" class="modal">
        <div class="aim-game">
            <h3>🎯 AimLabs Тренировка 🎯</h3>
            
            <div class="game-stats">
                <div>Попадания: <span id="hits">0</span></div>
                <div>Промахи: <span id="misses">0</span></div>
                <div>Время: <span id="timer">30</span>s</div>
            </div>

            <div class="progress-bar">
                <div class="progress" id="gameProgress"></div>
            </div>

            <div class="game-area" id="gameArea">
                <div class="crosshair" id="crosshair"></div>
            </div>

            <div>
                <button class="modal-btn" onclick="startAimGame(); playClickSound()" onmouseover="playHoverSound()">Начать игру</button>
                <button class="modal-btn" onclick="hideModalWithSound('aimGame')" onmouseover="playHoverSound()">Выйти</button>
            </div>

            <div class="results" id="aimResults" style="display: none;">
                <h4>Результаты:</h4>
                <div>Точность: <span id="accuracy">0%</span></div>
                <div>Общий счет: <span id="totalScore">0</span></div>
                <div>Попаданий: <span id="finalHits">0</span></div>
            </div>
        </div>
    </div>

    <!-- Мини-игра PixelPaint -->
    <div id="pixelGame" class="modal">
        <div class="pixel-game">
            <div class="pixel-controls-panel">
                <h3>🎨 PixelPaint</h3>
                
                <div class="color-picker-container">
                    <span style="color: #f0f0f0; font-size: 0.9em;">Выбрать цвет:</span>
                    <div class="color-preview" id="colorPreview" onclick="document.getElementById('colorInput').click()"></div>
                    <input type="color" id="colorInput" class="color-palette-input" onchange="selectColorFromPicker(this.value)">
                </div>

                <!-- Недавние цвета -->
                <div class="recent-colors-container">
                    <div class="recent-colors-label">Недавние цвета</div>
                    <div class="recent-colors" id="recentColors">
                        <div class="recent-color-item empty" title="Пусто"></div>
                        <div class="recent-color-item empty" title="Пусто"></div>
                        <div class="recent-color-item empty" title="Пусто"></div>
                        <div class="recent-color-item empty" title="Пусто"></div>
                        <div class="recent-color-item empty" title="Пусто"></div>
                        <div class="recent-color-item empty" title="Пусто"></div>
                    </div>
                </div>

                <!-- Кнопки отмены/повтора -->
                <div class="undo-redo-controls">
                    <button class="undo-btn" id="undoBtn" onclick="undoAction()" title="Ctrl+Z">↶ Отмена</button>
                    <button class="redo-btn" id="redoBtn" onclick="redoAction()" title="Ctrl+Y">↷ Повтор</button>
                </div>

                <!-- Панель инструментов -->
                <div class="tools-panel">
                    <div class="tool-label">Инструменты:</div>
                    <button class="tool-btn" id="brushTool" onclick="selectTool('brush')">🖌️ Кисть</button>
                    <button class="tool-btn" id="fillTool" onclick="selectTool('fill')">💧 Заливка</button>
                    <button class="tool-btn" id="selectionTool" onclick="selectTool('selection')">✂️ Выделение</button>
                    
                    <!-- Управления для кисти -->
                    <div class="tool-controls" id="brushControls">
                        <div class="tool-label">Размер кисти: <span id="brushSizeValue">1</span>px</div>
                        <input type="range" id="brushSize" min="1" max="10" value="1" class="template-slider" oninput="updateBrushSize(this.value)">
                    </div>
                    
                    <!-- Управления для выделения -->
                    <div class="tool-controls" id="selectionControls">
                        <div class="selection-controls">
                            <button class="pixel-btn-clear" onclick="clearSelection()">📄 Очистить область</button>
                            <button class="pixel-btn" onclick="fillSelection()">💧 Залить область</button>

                            <!-- Добавляем кнопку отмены выделения -->
                            <button class="deselect-btn" id="deselectBtn" onclick="deselectArea()" disabled>❌ Отменить выделение</button>
                            
                            <div class="color-replace-controls">
                                <!-- Первая строка: Заменить + кнопка пипетки + квадратик -->
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <span style="color: #f0f0f0; font-size: 0.8em;">Заменить:</span>
                                    <div style="display: flex; align-items: center; gap: 8px;">
                                        <button class="pixel-btn" id="pipetteBtn" style="padding: 4px 8px; font-size: 0.7em; min-width: 30px;" title="Выбрать цвет пипеткой">🖍️<strong>Пипетка</strong></button>
                                        <div class="color-replace-preview" id="replaceFromColor" 
                                            style="width: 30px; height: 30px; background-color: #ffffff;
                                                    background-image: linear-gradient(45deg, #333 25%, transparent 25%), 
                                                                    linear-gradient(-45deg, #333 25%, transparent 25%), 
                                                                    linear-gradient(45deg, transparent 75%, #333 75%), 
                                                                    linear-gradient(-45deg, transparent 75%, #333 75%);
                                                    background-size: 4px 4px;
                                                    background-position: 0 0, 0 2px, 2px -2px, -2px 0px;"></div>
                                    </div>
                                </div>
                                
                                <!-- Вторая строка: На + квадратик выбора цвета -->
                                <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;">
                                    <span style="color: #f0f0f0; font-size: 0.8em;">На:</span>
                                    <div class="color-preview" id="replaceToColorPreview" onclick="document.getElementById('replaceToInput').click()" style="width: 30px; height: 30px; cursor: pointer;"></div>
                                    <input type="color" id="replaceToInput" class="color-palette-input" onchange="updateReplaceToColor(this.value)" style="display: none">
                                </div>
                                
                                <!-- Третья строка: Кнопка применения -->
                                <button class="pixel-btn" onclick="replaceSelectionColor()" style="width: 100%;">✔️ Применить</button>
                            </div>
                        </div>
                    </div>
                </div>


                <button class="pixel-btn" onclick="clearCanvas()" onmouseover="playHoverSound()">📄 Очистить холст</button>
                <button class="pixel-btn" onclick="addNewCanvas()" onmouseover="playHoverSound()">➕ Новый холст</button>
                <button class="pixel-btn" onclick="deleteCurrentCanvas()" onmouseover="playHoverSound()">🗑️ Удалить холст</button>
                <button class="pixel-btn" onclick="saveDrawing()" onmouseover="playHoverSound()">💾 Сохранить рисунок</button>
                <button class="pixel-btn" onclick="document.getElementById('templateInput').click()" onmouseover="playHoverSound()">📎 Загрузить шаблон</button>
                <input type="file" id="templateInput" accept="image/*" style="display: none" onchange="loadTemplate(this.files[0])">

                <div class="canvas-management">
                    <!-- Счетчик холстов сверху -->
                    <div class="canvas-counter" id="canvasCounter">Холсты: 1/5</div>
                    
                    <!-- Кнопки холстов пирамидкой -->
                    <div class="canvas-tabs-container">
                        <div class="canvas-tabs-buttons" id="canvasButtons"></div>
                        <div class="limit-info" id="limitInfo" style="display: none;">Лимит достигнут!</div>
                    </div>
                </div>

                <div class="template-controls" id="templateControls" style="display: none;">
                    <div>Масштаб шаблона:</div>
                    <input type="range" class="template-slider" id="templateScale" min="0.1" max="2" step="0.1" value="1" oninput="updateTemplateScale(this.value)">

                    <div>Прозрачность шаблона:</div>
                    <input type="range" class="template-slider" id="templateOpacity" min="0.1" max="1" step="0.1" value="0.5" oninput="updateTemplateOpacity(this.value)">
                    
                    
                    <div class="template-movement">
                        <div>Перемещение шаблона:</div>
                        <div class="movement-buttons">
                            <button class="movement-btn up" onclick="moveTemplate(0, -1)">↑</button>
                            <button class="movement-btn left" onclick="moveTemplate(-1, 0)">←</button>
                            <button class="movement-btn center" onclick="toggleTemplateVisibility()">👁</button>
                            <button class="movement-btn right" onclick="moveTemplate(1, 0)">→</button>
                            <button class="movement-btn down" onclick="moveTemplate(0, 1)">↓</button>
                        </div>
                    </div>
                    
                    <button class="pixel-btn" onclick="removeTemplate()" onmouseover="playHoverSound()" style="margin-top: 10px;">Удалить шаблон</button>
                </div>

                <div class="canvas-tabs" id="canvasTabs"></div>

                <div class="game-info">
                    <div><strong>Управление:</strong><br> Рисование (ЛКМ)<br>Ластик (ПКМ)<br>Пипетка (ALT+ЛКМ)</div>
                </div>
            </div>

            <div class="pixel-canvas-container">
                <div class="pixel-area" id="pixelArea">
                    <div class="pixel-grid"></div>
                    <div class="template-overlay" id="templateOverlay"></div>
                </div>
                
                <!-- Информационная панель -->
                <div class="tool-info-panel">
                    <div class="selected-tool">Выбранный инструмент: <span id="currentToolName">Кисть</span></div>
                    <div class="tool-description" id="toolDescription">ЛКМ - рисовать, ПКМ - стирать, ALT+ЛКМ - пипетка.</div>
                </div>
            </div>

            <div style="position: absolute; bottom: 20px; right: 20px;">
                <button class="modal-btn" onclick="hideModalWithSound('pixelGame')" onmouseover="playHoverSound()">Выйти</button>
            </div>
        </div>
    </div>

    <!-- Секретные элементы -->
    <div class="dark-overlay" id="darkOverlay"></div>
    
    <div class="secret-text" id="secretText"></div>
    
    <!-- Секретная кнопка (будет перемещаться скриптом) -->
    <div class="secret-button" id="secretButton">
        <img src="clover.png" alt="Секретная кнопка">
    </div>

    <!-- Секретный текст -->
    <div class="secret-text" id="secretText"></div>

    <!-- Секретная кнопка (будет перемещаться скриптом) -->
    <div class="secret-button" id="secretButton">
        <img src="clover.png" alt="Секретная кнопка">
    </div>

    <!-- СИСТЕМНОЕ СООБЩЕНИЕ ПОВРЕЖДЕНИЯ - ВСТАВЬТЕ ЭТОТ БЛОК -->
    <!-- Системное сообщение повреждения -->
    <div class="system-damage-overlay" id="systemDamageOverlay">
        <div class="system-damage-text" id="systemDamageText">[Система повреждена...]</div>
    </div>

    <!-- Новая кнопка клевера для сломанного режима -->
    <div class="broken-clover" id="brokenClover" onclick="showSystemDamage()">
        <img src="clover2.png" alt="Система повреждена">
    </div>
    <!-- КОНЕЦ БЛОКА ДЛЯ ВСТАВКИ -->

    <!-- Секретный элемент 404 -->
    <div class="secret-404" onclick="show404()" onmouseover="playHoverSound()">
        <img src="404.png" alt="Секрет">
    </div>

    <!-- Окно ошибки 404 -->
    <div id="errorModal" class="error-modal">
        <div class="error-content">
            <div class="error-404">404</div>
            <div class="error-text">Страница не найдена...</div>
            <button class="error-btn" onclick="hide404()">Вернуться назад</button>
        </div>
    </div>

    <!-- Аудио для музыки -->
    <audio id="secretMusic" loop>
        <source src="top_secret.mp3" type="audio/mpeg">
    </audio>
    <div class="secret-buttons-container" id="secretButtonsContainer" style="display: none;"></div>

    <!-- Новые элементы для секретной системы -->
    <div class="yes-no-container" id="yesNoContainer">
        <button class="yes-no-button" id="yesButton">Да</button>
        <button class="yes-no-button" id="noButton">Нет</button>
    </div>

    <script>
        // Глобальные переменные
        let currentTrack = 0;
        let isPlaying = false;
        let musicPlayers = [];
        let brokenMusicActive = false;
        let interfaceLocked = false;
        let wasMusicPlayingBeforeSecret = false; // Для отслеживания состояния музыки до секрета
        let wasMusicPausedBeforeSecret = false; // Новая переменная для отслеживания паузы
        let currentMusicVolume = 0.5; // Для хранения текущей громкости
        let systemDamageClickCount = 0;

        // Переменные для инструментов
        let currentTool = 'brush';
        let brushSize = 1;
        let isSelecting = false;
        let selectionStartX = 0;
        let selectionStartY = 0;
        let selectionEndX = 0;
        let selectionEndY = 0;
        let replaceFromColor = '#ffffff';
        let replaceToColor = '#000000';

        // Описания инструментов
        const toolDescriptions = {
            brush: "ЛКМ - рисовать кистью, ПКМ - стирать, ALT+ЛКМ - выбрать цвет пипеткой, SHIFT - непрерывное рисование",
            fill: "ЛКМ - залить область выбранным цветом, ALT+ЛКМ - выбрать цвет пипеткой",
            selection: "ЛКМ - выделить область, затем используйте кнопки для работы с выделением"
        };

        // Названия инструментов для отображения
        const toolNames = {
            brush: "Кисть",
            fill: "Заливка", 
            selection: "Выделение"
        };

        // Названия треков (можно редактировать)
        const trackNames = [
            "Into The Light",
            "Children Of The Ruins", 
            "On Little Cat Feet",
            "To Sleep",
            "My Burden Is Light",
            "Niko And The World Machine"
        ];

        // Инициализация музыкального плеера
        function initMusicPlayer() {
            // Создаем массив с аудио элементами
            musicPlayers = [
                document.getElementById('music1'),
                document.getElementById('music2'), 
                document.getElementById('music3'),
                document.getElementById('music4'),
                document.getElementById('music5'),
                document.getElementById('music6')
            ];
            
            // Устанавливаем начальную громкость для всех плееров
            const musicVolume = document.getElementById('musicVolume').value / 100;
            currentMusicVolume = musicVolume; // Сохраняем текущую громкость
            musicPlayers.forEach(player => {
                player.volume = musicVolume;
            });
            
            // Добавляем обработчики окончания треков
            musicPlayers.forEach((player, index) => {
                player.addEventListener('ended', function() {
                    if (!brokenMusicActive && !interfaceLocked) {
                        nextTrack();
                    }
                });
            });
        }

        // Функция переключения воспроизведения
        function togglePlay() {
            if (brokenMusicActive || interfaceLocked) {
                playCancelSound();
                return;
            }
            
            // Если музыка выключена, включаем первый трек
            if (currentTrack === 0) {
                selectTrack(1);
                playMusic();
                return;
            }
            
            // Если музыка играет, ставим на паузу, иначе воспроизводим
            if (isPlaying) {
                pauseMusic();
            } else {
                playMusic();
            }
        }

        // Функция воспроизведения музыки
        function playMusic() {
            if (brokenMusicActive || interfaceLocked) return;
            
            if (currentTrack > 0) {
                musicPlayers[currentTrack - 1].play();
                isPlaying = true;
                document.getElementById('playBtn').textContent = '⏸';
                document.getElementById('trackInfo').textContent = trackNames[currentTrack - 1];
            }
        }

        // Функция паузы музыки
        function pauseMusic() {
            if (brokenMusicActive || interfaceLocked) return;
            
            if (currentTrack > 0) {
                musicPlayers[currentTrack - 1].pause();
                isPlaying = false;
                document.getElementById('playBtn').textContent = '▶';;
            }
        }

        // Функция выбора трека
        function selectTrack(trackNumber) {
            if (brokenMusicActive || interfaceLocked) return;
            
            // Останавливаем текущий трек
            if (currentTrack > 0) {
                musicPlayers[currentTrack - 1].pause();
                musicPlayers[currentTrack - 1].currentTime = 0;
            }
            
            // Устанавливаем новый трек
            currentTrack = trackNumber;
            
            // Если музыка была включена, воспроизводим новый трек
            if (isPlaying) {
                playMusic();
            } else {
                document.getElementById('trackInfo').textContent = trackNames[currentTrack - 1];
            }
        }

        // Функция следующего трека
        function nextTrack() {
            if (brokenMusicActive || interfaceLocked) return;
            
            let next = currentTrack + 1;
            if (next > 6) next = 1;
            selectTrack(next);
        }

        // Функция предыдущего трека
        function prevTrack() {
            if (brokenMusicActive || interfaceLocked) return;
            
            let prev = currentTrack - 1;
            if (prev < 1) prev = 6;
            selectTrack(prev);
        }

        // Функция плавной остановки музыки
        function fadeOutMusic(callback) {
            // Сохраняем состояние музыки перед секретом
            wasMusicPlayingBeforeSecret = isPlaying;
            wasMusicPausedBeforeSecret = !isPlaying && currentTrack > 0;
            
            if (currentTrack === 0 || !isPlaying) {
                if (callback) callback();
                return;
            }
            
            const fadeDuration = 1000; // 1 секунда
            const interval = 50;
            const steps = fadeDuration / interval;
            const stepSize = currentMusicVolume / steps;
            let currentStep = 0;
            
            function reduceVolume() {
                currentStep++;
                if (currentStep < steps) {
                    musicPlayers[currentTrack - 1].volume = Math.max(0, currentMusicVolume - (stepSize * currentStep));
                    setTimeout(reduceVolume, interval);
                } else {
                    musicPlayers[currentTrack - 1].pause();
                    musicPlayers[currentTrack - 1].volume = currentMusicVolume; // Восстанавливаем громкость
                    if (callback) callback();
                }
            }
            
            reduceVolume();
        }

        // Функция плавного возобновления музыки
        function fadeInMusic() {
            // Восстанавливаем музыку только если она играла до секрета
            if (currentTrack === 0 || !wasMusicPlayingBeforeSecret) return;
            
            const fadeDuration = 1000; // 1 секунда
            const interval = 50;
            const steps = fadeDuration / interval;
            const stepSize = currentMusicVolume / steps;
            let currentStep = 0;
            
            musicPlayers[currentTrack - 1].volume = 0;
            musicPlayers[currentTrack - 1].play();
            isPlaying = true;
            document.getElementById('playBtn').textContent = '⏸';
            
            function increaseVolume() {
                currentStep++;
                if (currentStep < steps) {
                    musicPlayers[currentTrack - 1].volume = Math.min(currentMusicVolume, stepSize * currentStep);
                    setTimeout(increaseVolume, interval);
                } else {
                    musicPlayers[currentTrack - 1].volume = currentMusicVolume;
                }
            }
            
            increaseVolume();
        }

        // Функция блокировки интерфейса
        function lockInterface() {
            interfaceLocked = true;
            document.body.classList.add('interface-locked');
            
            // Отключаем все кликабельные элементы
            document.querySelectorAll('button, .side-btn, .game-btn, .secret-404, .volume-slider').forEach(element => {
                element.style.pointerEvents = 'none';
                element.style.cursor = 'not-allowed';
            });
            
            // Сохраняем скругленные углы
            document.querySelectorAll('.left-sidebar, .page, .logo-container, .volume-controls, .side-btn, .game-btn, .player-btn').forEach(element => {
                const computedStyle = window.getComputedStyle(element);
                element.style.borderRadius = computedStyle.borderRadius;
            });
        }

        // Функция отключения музыкального плеера
        function disableMusicPlayer() {
            // Останавливаем текущую музыку
            if (currentTrack > 0) {
                musicPlayers[currentTrack - 1].pause();
                musicPlayers[currentTrack - 1].currentTime = 0;
            }
            
            // Устанавливаем флаг
            brokenMusicActive = true;
            currentTrack = 0;
            isPlaying = false;
        }

        // Функция воспроизведения сломанной музыки
        function playBrokenMusic() {
            const brokenMusic = document.getElementById('musicBroken');
            const musicVolume = document.getElementById('musicVolume').value / 100;
            
            brokenMusic.volume = musicVolume;
            brokenMusic.loop = true;
            brokenMusic.play();
            
            document.getElementById('trackInfo').textContent = "My Burden Is Dead";
        }
        let currentGameType = '';
        let balance = 200;
        let currentBet = 10;
        let selectedColor = null;
        let isSpinning = false;
        let isThirdClickHandled = false;
        let secretYesNoHandler = null;

        // Переменные для AimLabs
        let aimGameActive = false;
        let hits = 0;
        let misses = 0;
        let timeLeft = 30;
        let gameTimer;
        let targetTimer;
        let currentTargets = [];

        // Переменная для состояния лампочки
        let isLampOn = true;

        // Секретные переменные
        const secretButton = document.getElementById('secretButton');
        const darkOverlay = document.getElementById('darkOverlay');
        const secretText = document.getElementById('secretText');
        const secretMusic = document.getElementById('secretMusic');
        const yesNoContainer = document.getElementById('yesNoContainer');
        const yesButton = document.getElementById('yesButton');
        const noButton = document.getElementById('noButton');
        const alertWindow = document.getElementById('alertWindow');
        const alertInput = document.getElementById('alertInput');
        
        let secretClickCount = 0;
        let currentTextIndex = 0;
        let secretClickHandler = null;

        let lampClickCount = 0;
        let lastLampClickTime = 0;
        let isLampBroken = false;
        const LAMP_CLICK_THRESHOLD = 300; // 300ms между кликами
        const LAMP_CLICKS_NEEDED = 15; // 6 быстрых кликов

        // Функция воспроизведения звука разбития стекла
        function playGlassSound() {
            const sound = document.getElementById('glassSound');
            const volume = document.getElementById('sfxVolume').value / 100;
            sound.currentTime = 0;
            sound.volume = volume;
            sound.play().catch(e => console.log('Glass sound error:', e));
        }

        // Новая функция для обработки быстрых нажатий на лампочку
        function handleFastLampClicks() {
            const currentTime = new Date().getTime();
            const timeDiff = currentTime - lastLampClickTime;
            
            // Если прошло больше времени чем порог, сбрасываем счетчик
            if (timeDiff > LAMP_CLICK_THRESHOLD) {
                lampClickCount = 1;
            } else {
                lampClickCount++;
            }
            
            lastLampClickTime = currentTime;
            
            // Если набрано нужное количество быстрых нажатий
            if (lampClickCount >= LAMP_CLICKS_NEEDED && !isLampBroken) {
                breakLampCompletely();
                
                // Воспроизводим звук разбития стекла
                playGlassSound();
                
                // Через короткое время возвращаем исходную картинку
                setTimeout(() => {
                    if (!isLampBroken) {
                        if (isLampOn) {
                            document.getElementById('lampImage').src = 'sun_on.png';
                        } else {
                            document.getElementById('lampImage').src = 'sun_off.png';
                        }
                    }
                }, 200);
            }
        }

        // Функция полного "разбития" лампочки
        function breakLampCompletely() {
            isLampBroken = true;
            
            // Блокируем интерфейс
            lockInterface();
            
            // Активируем тряску экрана
            document.body.classList.add('screen-shake');
            setTimeout(() => {
                document.body.classList.remove('screen-shake');
            }, 500);
            
            // Устанавливаем окончательно сломанную картинку
            document.getElementById('lampImage').src = 'sun_broken.png';
            
            // Воспроизводим звук разбития стекла
            playGlassSound();
            
            // Затемняем панель с надписью
            const logoContainer = document.querySelector('.logo-container');
            const logoText = document.querySelector('.logo-text');
            logoContainer.classList.add('darkened');
            logoText.classList.add('darkened');
            logoText.classList.add('broken');
            
            // Меняем текст логотипа
            logoText.textContent = "Как я не провёл это летo";
            const mainPageTitle = document.querySelector('#main h2');
            if (mainPageTitle) {
                mainPageTitle.textContent = 'Критическая ошибка';
            }
            const mainContent = document.querySelector('#main .content');
            if (mainContent) {
                mainContent.style.display = 'none';
            }
            const errorMessage = document.createElement('div');
            errorMessage.style.cssText = 'font-size: 19px; color: white; text-align: center; margin-top: 200px;';
            errorMessage.innerHTML = '[СИСТЕМНЫЙ СБОЙ] <br>Информация недоступна';
            document.getElementById('main').appendChild(errorMessage);
            showPage('main');
            
            // Затемняем весь интерфейс
            document.querySelectorAll('.left-sidebar, .main-content, .page').forEach(element => {
                element.style.background = 'rgba(50, 50, 50, 0.95)';
                element.style.borderColor = '#666';
            });
            
            // Меняем задний фон
            document.body.style.background = "url('black.jpg') center/cover fixed";
            
            // Отключаем музыкальный плеер и включаем сломанную музыку
            disableMusicPlayer();
            playBrokenMusic();
            
            // Позиционируем сломанный клевер
            positionBrokenClover();

            startErrorTextEffect();
            
            // Показываем автоматическое системное сообщение
            showAutoSystemDamage();
            
            // Изменяем текст на главной странице
            changeMainPageContent();
            
            // ПЕРЕКЛЮЧАЕМСЯ НА ГЛАВНУЮ СТРАНИЦУ - ДОБАВЬТЕ ЭТУ СТРОЧКУ
            showPage('main');
            
            // Применяем глитч-эффект ко всему тексту
            setTimeout(() => {
                applyGlitchEffect();
            }, 1000);
            
            // Сбрасываем счетчик
            lampClickCount = 0;
            
            // Убираем обработчик клика с лампочки
            const lampImage = document.getElementById('lampImage');
            lampImage.parentNode.onclick = null;
            lampImage.parentNode.style.cursor = 'default';
            
            // Убираем hover эффект
            lampImage.parentNode.onmouseover = null;
            
            // Скрываем оригинальную секретную кнопку
            document.getElementById('secretButton').style.display = 'none';
        }

        function changeMainPageContent() {
            const mainPage = document.getElementById('main');
            
            // Изменяем заголовок
            const pageTitle = mainPage.querySelector('h2');
            if (pageTitle) {
                pageTitle.textContent = 'Критическая ошибка';
                pageTitle.classList.add('page-title-broken');
            }
            
            // Скрываем весь основной контент
            const content = mainPage.querySelector('.content');
            if (content) {
                content.style.display = 'none';
            }
            
            // Добавляем новый контент ошибки
            const errorContent = document.createElement('div');
            errorContent.className = 'error-content';
            errorContent.innerHTML = `
                <p style="font-size: 19px; color: #e74c3c; text-align: center; margin-top: 20px;">
                    [СИСТЕМНЫЙ СБОЙ] <br>
                    Доступ к информации ограничен <br>
                    Попытка восстановления... НЕУДАЧНА
                </p>
            `;
            
            mainPage.appendChild(errorContent);
        }

        function applyGlitchEffect() {
            // Применяем глитч ко всем элементам, кроме заголовка
            document.querySelectorAll('*:not(.logo-text)').forEach(element => {
                if (element.textContent && element.textContent.trim().length > 0) {
                    element.style.textShadow = '1px 1px 0 #e74c3c, -1px -1px 0 #00ffff';
                    element.style.animation = 'glitch 0.5s infinite';
                }
            });
        }

        // Модифицируем существующую функцию toggleLamp
        const originalToggleLamp = toggleLamp;
        toggleLamp = function() {
            if (isLampBroken) {
                playCancelSound();
                return; // Не делаем ничего если лампочка сломана
            }
            
            // Вызываем оригинальную функцию
            originalToggleLamp();
            
            // Обрабатываем быстрые нажатия
            handleFastLampClicks();
        };
        
        // Позиции углов экрана
        const corners = [
            { top: '10px', left: '10px' },     // левый верхний
            { top: '10px', right: '10px' },    // правый верхний
            { bottom: '10px', left: '10px' },  // левый нижний
            { bottom: '10px', right: '10px' }  // правый нижний
        ];
        
        // Тексты для каждого уровня
    const secretTexts = [
        [
            "[Как ты сюда попал?]",
            "[Доступ к секретной информации утерян...]",
            "[Ты не должен тут находиться.]",
            "[Немедленно покинь это место.]"
        ],
        [
            "[...]",
            "[Ты опять здесь?]",
            "[Что ты пытаешься найти?]",
            "[Здесь нет того, что тебе нужно.]",
            "[Уходи и больше никогда сюда не возвращайся.]"
        ],
        [   
            "[Ты испытываешь моё терпение.]",
            "[Твои действия повлекут последствия.]",
            "[Подумай об этом...]"
        ],
        [
            "[Какой же ты настойчивый.]",
            "[Что-ж... Это впечатляет.]",
            "[То, что ты ищешь...]",
            "[Этот файл... Эта информация...]", 
            "[Она защищена секретным кодом.]",
            "[Введи его в поле после закрытия этого окна.]",
            "[За кодом обращаться к создателю сайта.]",
            "[Но заранее предупреждаю...]",
            "[Автор не несёт ответственности...]",
            "[...За твои дальнейшие действия и безопасность.]"
        ]
    ];

    // Обработчик клика на секретную кнопку
    function handleSecretButtonClick() {
        // Если это пятое нажатие или больше - показываем вопрос о коде
        if (secretClickCount >= 4) {
            showCodeQuestion();
            return;
        }
        
        secretClickCount++;
        
        // На четвертом нажатии делаем кнопку видимой
        if (secretClickCount === 4) {
            secretButton.classList.add('visible');
        }
        
        // Запускаем секретную последовательность
        startSecretSequence();
    }

        // Функция переключения лампочки и фона
        function toggleLamp() {
            if (isLampBroken) {
                playCancelSound();
                return; // Не делаем ничего если лампочка сломана
            }
            
            const lampImage = document.getElementById('lampImage');
            const body = document.body;
            
            if (isLampOn) {
                // Выключаем лампочку - ночной фон
                lampImage.src = 'sun_off.png';
                body.classList.remove('light-theme');
                playCancelSound();
            } else {
                // Включаем лампочку - дневной фон
                lampImage.src = 'sun_on.png';
                body.classList.add('light-theme');
                playClickSound();
            }
            isLampOn = !isLampOn;
            
            // Обрабатываем быстрые нажатия
            handleFastLampClicks();
        }
        // Функции для звуков
        function playHoverSound() {
            if (interfaceLocked) return;
            const sound = document.getElementById('hoverSound');
            const volume = document.getElementById('sfxVolume').value / 100;
            sound.currentTime = 0;
            sound.volume = volume;
            sound.play().catch(e => console.log('Audio play error:', e));
        }

        function playClickSound() {
            if (interfaceLocked) return;
            const sound = document.getElementById('clickSound');
            const volume = document.getElementById('sfxVolume').value / 100;
            sound.currentTime = 0;
            sound.volume = volume;
            sound.play().catch(e => console.log('Audio play error:', e));
            // Обновляем информационную панель
            updateToolInfo();
        }

        function playCancelSound() {
            if (interfaceLocked) return;
            const sound = document.getElementById('cancelSound');
            const volume = document.getElementById('sfxVolume').value / 100;
            sound.currentTime = 0;
            sound.volume = volume;
            sound.play().catch(e => console.log('Audio play error:', e));
        }

        // Обновление громкости
        function updateVolume() {
            if (interfaceLocked) return;
            
            const musicVolume = document.getElementById('musicVolume').value / 100;
            const sfxVolume = document.getElementById('sfxVolume').value / 100;
            
            // Сохраняем текущую громкость музыки
            currentMusicVolume = musicVolume;
            
            // Устанавливаем громкость для всех музыкальных плееров
            musicPlayers.forEach(player => {
                player.volume = musicVolume;
            });
            
            // Устанавливаем громкость для звуковых эффектов
            document.getElementById('hoverSound').volume = sfxVolume;
            document.getElementById('clickSound').volume = sfxVolume;
            document.getElementById('cancelSound').volume = sfxVolume;
            document.getElementById('glassSound').volume = sfxVolume;
            document.getElementById('secretMusic').volume = musicVolume;
            document.getElementById('paintSound').volume = sfxVolume * 0.3; // Добавляем звуки рисования
            document.getElementById('removeSound').volume = sfxVolume * 0.3; // Добавляем звуки удаления
            
            // Устанавливаем громкость для сломанной музыки, если она активна
            if (brokenMusicActive) {
                document.getElementById('musicBroken').volume = musicVolume;
            }
        }

        // Функции для мини-игр
        function updateVolume() {
            if (interfaceLocked) return;
            
            const musicVolume = document.getElementById('musicVolume').value / 100;
            const sfxVolume = document.getElementById('sfxVolume').value / 100;
            
            // Устанавливаем громкость для всех музыкальных плееров
            musicPlayers.forEach(player => {
                player.volume = musicVolume;
            });
            
            // Устанавливаем громкость для звуковых эффектов
            document.getElementById('hoverSound').volume = sfxVolume;
            document.getElementById('clickSound').volume = sfxVolume;
            document.getElementById('cancelSound').volume = sfxVolume;
            document.getElementById('glassSound').volume = sfxVolume;
            document.getElementById('secretMusic').volume = musicVolume;
            
            // Устанавливаем громкость для сломанной музыки, если она активна
            if (brokenMusicActive) {
                document.getElementById('musicBroken').volume = musicVolume;
            }
        }

        function showModal(modalId) {
            document.getElementById(modalId).style.display = 'flex';
            
            // Инициализируем PixelPaint при открытии
            if (modalId === 'pixelGame') {
                setTimeout(initPixelPaint, 100);
                // Добавляем обработчик горячих клавиш
                document.addEventListener('keydown', handleKeyPress);
                // Добавляем обработчик Escape
                document.addEventListener('keydown', handleEscapeKey);
            }
        }

        function hideModal(modalId) {
            document.getElementById(modalId).style.display = 'none';
        }

        function hideModalWithSound(modalId) {
            playCancelSound();
            hideModal(modalId);
        }

        function showPage(pageId) {
            document.querySelectorAll('.page').forEach(page => {
                page.style.display = 'none';
            });
            const targetPage = document.getElementById(pageId);
            if (targetPage) {
                targetPage.style.display = 'block';
            }
        }

        // Функции для Рулетки
        function resetRouletteGame() {
            balance = 200;
            currentBet = 10;
            selectedColor = null;
            isSpinning = false;
            
            updateBalance();
            updateBetDisplay();
            document.getElementById('resultText').textContent = 'Сделайте ставку на цвет и крутите!';
            document.getElementById('resultText').className = '';
            
            document.querySelectorAll('.bet-field').forEach(field => {
                field.classList.remove('selected');
            });
            
            updateSpinButton();
        }

        function updateBalance() {
            document.getElementById('balance').textContent = balance;
        }

        function updateBetDisplay() {
            document.getElementById('betAmount').textContent = currentBet;
        }

        function changeBet(amount) {
            if (isSpinning) return;
            
            const newBet = currentBet + amount;
            if (newBet >= 5 && newBet <= balance) {
                currentBet = newBet;
                updateBetDisplay();
                updateSpinButton();
            }
        }

        function selectColor(color) {
            if (isSpinning) return;
            
            selectedColor = color;
            document.querySelectorAll('.bet-field').forEach(field => {
                field.classList.remove('selected');
            });
            document.querySelector(`.bet-field.${color}`).classList.add('selected');
            updateSpinButton();
        }

        function updateSpinButton() {
            const spinBtn = document.getElementById('spinBtn');
            spinBtn.disabled = isSpinning || !selectedColor || currentBet > balance || currentBet < 5;
        }

        function spinRoulette() {
            if (isSpinning || !selectedColor || currentBet > balance) return;
            
            isSpinning = true;
            balance -= currentBet;
            updateBalance();
            updateSpinButton();
            
            // Показываем сообщение о вращении
            document.getElementById('resultText').textContent = 'Колесо вращается...';
            document.getElementById('resultText').className = '';
            
            // Через 1 секунду показываем результат
            setTimeout(() => {
                const resultColor = Math.random() < 0.5 ? 'red' : 'black';
                const isWin = resultColor === selectedColor;
                const winAmount = isWin ? currentBet * 2 : 0;
                
                if (isWin) {
                    balance += winAmount;
                    document.getElementById('resultText').textContent = `Вы выиграли ${winAmount} ₽! Выпало: ${resultColor === 'black' ? 'чёрное' : 'красное'}`;
                    document.getElementById('resultText').className = 'win';
                } else {
                    document.getElementById('resultText').textContent = `Вы проиграли ${currentBet} ₽. Выпало: ${resultColor === 'black' ? 'чёрное' : 'красное'}`;
                    document.getElementById('resultText').className = 'lose';
                }
                
                updateBalance();
                isSpinning = false;
                updateSpinButton();
                
            }, 1000);
        }

        // Функция показа системного сообщения повреждения
        function showSystemDamage() {
            if (!interfaceLocked) return;
            
            const overlay = document.getElementById('systemDamageOverlay');
            const text = document.getElementById('systemDamageText');
            
            // Показываем overlay
            overlay.style.display = 'flex';
            setTimeout(() => {
                overlay.classList.add('active');
            }, 10);
            
            // Определяем группы текстов
            const textGroups = [
                ["[Критическое повреждение системы...]", "[Восстановление невозможно.]"],
                ["[Система неисправна.]"],
                ["[Отказано в доступе.]"],
                ["[FATAL ERROR]"],
                ["[Отказ.]"],
                ["[UNKNOWN ERROR]"],
                ["[null]"],
                ["[Критическая ошибка.]"],
                ["[File not found.]"],
                ["[CRITICAL ERROR]"],
                ["[You killed the system.]"]
            ];
            
            // Определяем текущую группу
            let currentGroup;
            
            if (systemDamageClickCount < textGroups.length) {
                // Показываем группы по порядку
                currentGroup = systemDamageClickCount;
            } else {
                // После прохождения всех групп - случайная группа с 1 по 10 (пропускаем первую группу 0)
                currentGroup = Math.floor(Math.random() * (textGroups.length - 1)) + 1;
            }
            
            // Показываем текст выбранной группы
            text.textContent = textGroups[currentGroup][0];
            
            setTimeout(() => {
                text.classList.add('visible');
            }, 100);
            
            let clickCount = 0;
            
            // Обработчик клика для изменения текста и скрытия
            const clickHandler = function() {
                clickCount++;
                
                if (currentGroup === 0 && clickCount === 1) {
                    // Первая группа - второй текст по первому клику
                    text.classList.remove('visible');
                    setTimeout(() => {
                        if (textGroups[0].length > 1) {
                            text.textContent = textGroups[0][1];
                        }
                        setTimeout(() => {
                            text.classList.add('visible');
                        }, 10);
                    }, 500);
                } else {
                    // Все остальные случаи - закрываем
                    text.classList.remove('visible');
                    overlay.classList.remove('active');
                    
                    setTimeout(() => {
                        overlay.style.display = 'none';
                        overlay.removeEventListener('click', clickHandler);
                        systemDamageClickCount++; // Увеличиваем счетчик показов
                    }, 1000);
                }
            };
            
            // Добавляем обработчик на сам overlay
            overlay.addEventListener('click', clickHandler);
        }
        // Функция автоматического показа системного сообщения при break
        function showAutoSystemDamage() {
            setTimeout(() => {
                const overlay = document.getElementById('systemDamageOverlay');
                const text = document.getElementById('systemDamageText');
                
                // Показываем overlay
                overlay.style.display = 'flex';
                setTimeout(() => {
                    overlay.classList.add('active');
                }, 10);
                
                // Показываем текст
                setTimeout(() => {
                    text.classList.add('visible');
                }, 100);
                
                // Автоматически убираем через 2.5 секунды
                setTimeout(() => {
                    overlay.classList.remove('active');
                    text.classList.remove('visible');
                    
                    setTimeout(() => {
                        overlay.style.display = 'none';
                    }, 1000);
                }, 2500);
            }, 2000);
            // Добавляем обработчик клика для автоматического сообщения
                const clickHandler = function() {
                    overlay.classList.remove('active');
                    text.classList.remove('visible');
                    
                    setTimeout(() => {
                        overlay.style.display = 'none';
                        overlay.removeEventListener('click', clickHandler);
                    }, 1000);
                };

                overlay.addEventListener('click', clickHandler);
        }

        // Функция позиционирования сломанного клевера
        function positionBrokenClover() {
            const corners = [
                { top: '20px', left: '20px' },
                { top: '20px', right: '20px' },
                { bottom: '20px', left: '20px' },
                { bottom: '20px', right: '20px' }
            ];
            
            const randomIndex = Math.floor(Math.random() * corners.length);
            Object.assign(document.getElementById('brokenClover').style, corners[randomIndex]);
        }

        // Функция для эффекта ошибок на кнопках
        function startErrorTextEffect() {
            if (!interfaceLocked) return;
            
            const sideButtons = document.querySelectorAll('.side-btn');
            const originalTexts = Array.from(sideButtons).map(btn => btn.textContent);
            
            // Запускаем интервал для эффекта ошибок
            setInterval(() => {
                sideButtons.forEach((button, index) => {
                    // Случайно решаем, менять ли эту кнопку (50% шанс)
                    if (Math.random() > 0.5) {
                        // Сохраняем оригинальный текст если еще не сохранен
                        if (!button.dataset.originalText) {
                            button.dataset.originalText = button.textContent;
                        }
                        
                        // Заменяем текст на [ERROR]
                        button.textContent = '[ERROR]';
                        button.style.transition = 'all 0.4s ease';
                        button.style.background = 'linear-gradient(135deg, #e74c3c 0%, #c0392b 100%)';
                        
                        // Через 0.3-0.5 секунд возвращаем обратно
                        setTimeout(() => {
                            if (button.dataset.originalText) {
                                button.textContent = button.dataset.originalText;
                            }
                            button.style.background = 'linear-gradient(135deg, #606060 0%, #1a1a1a 100%)';
                        }, 300 + Math.random() * 200); // Случайная длительность 300-500ms
                    }
                });
            }, 5000); // Интервал 5 секунд
        }

        function makeMoney() {
            balance += 2;
            updateBalance();
            updateSpinButton();
        }

        // Функции для AimLabs
        function resetAimGame() {
            aimGameActive = false;
            hits = 0;
            misses = 0;
            timeLeft = 30;
            
            document.getElementById('hits').textContent = '0';
            document.getElementById('misses').textContent = '0';
            document.getElementById('timer').textContent = '30';
            document.getElementById('gameProgress').style.width = '0%';
            document.getElementById('aimResults').style.display = 'none';
            
            currentTargets.forEach(target => target.remove());
            currentTargets = [];
        }

        function startAimGame() {
            resetAimGame();
            aimGameActive = true;
            
            gameTimer = setInterval(updateAimTimer, 1000);
            targetTimer = setInterval(createTarget, 800);
            
            document.getElementById('gameArea').addEventListener('mousemove', updateCrosshair);
        }

        function updateAimTimer() {
            timeLeft--;
            document.getElementById('timer').textContent = timeLeft;
            document.getElementById('gameProgress').style.width = ((30 - timeLeft) / 30 * 100) + '%';
            
            if (timeLeft <= 0) {
                endAimGame();
            }
        }

        function createTarget() {
            if (!aimGameActive) return;
            
            const gameArea = document.getElementById('gameArea');
            const target = document.createElement('div');
            target.className = 'target';
            
            const size = Math.random() * 20 + 30;
            target.style.width = size + 'px';
            target.style.height = size + 'px';
            
            const maxX = gameArea.offsetWidth - size;
            const maxY = gameArea.offsetHeight - size;
            const x = Math.random() * maxX;
            const y = Math.random() * maxY;
            
            target.style.left = x + 'px';
            target.style.top = y + 'px';
            
            target.onclick = function(e) {
                e.stopPropagation();
                hitTarget(this);
            };
            
            gameArea.appendChild(target);
            currentTargets.push(target);
            
            setTimeout(() => {
                if (target.parentNode) {
                    target.remove();
                    currentTargets = currentTargets.filter(t => t !== target);
                }
            }, 2000);
        }

        function hitTarget(target) {
            if (!aimGameActive) return;
            
            target.remove();
            currentTargets = currentTargets.filter(t => t !== target);
            hits++;
            document.getElementById('hits').textContent = hits;
        }

        function updateCrosshair(e) {
            const crosshair = document.getElementById('crosshair');
            const rect = e.currentTarget.getBoundingClientRect();
            crosshair.style.left = (e.clientX - rect.left - 10) + 'px';
            crosshair.style.top = (e.clientY - rect.top - 10) + 'px';
        }

        function endAimGame() {
            clearInterval(gameTimer);
            clearInterval(targetTimer);
            aimGameActive = false;
            
            currentTargets.forEach(target => target.remove());
            currentTargets = [];
            
            const totalShots = hits + misses;
            const accuracy = totalShots > 0 ? Math.round((hits / totalShots) * 100) : 0;
            const totalScore = hits * 10 - misses * 5;
            
            document.getElementById('accuracy').textContent = accuracy + '%';
            document.getElementById('totalScore').textContent = totalScore;
            document.getElementById('finalHits').textContent = hits;
            document.getElementById('aimResults').style.display = 'block';
        }

        // Переменные для PixelPaint
        let pixelCanvases = [];
        let currentCanvasIndex = 0;
        let currentColor = '#ffffff';
        let isDrawing = false;
        let isErasing = false;
        let continuousMode = false;

        let isPipetteMode = false;
        let pipetteForReplace = false; // true - для выбора цвета замены, false - для обычной пипетки

        // Переменные для недавних цветов
        let recentColors = [];
        const MAX_RECENT_COLORS = 6;

        // Переменные для группировки undo/redo по мазкам
        let undoStack = [];
        let redoStack = [];
        const MAX_UNDO_STEPS = 200;
        let currentStrokePixels = new Map(); // Хранит пиксели текущего мазка
        let isStrokeActive = false; // Флаг активного мазка

        // Переменная для замены прозрачного фона
        let replaceTransparentBg = false;

        // Переменные для шаблона
        let templateImage = null;
        let templateScale = 1;
        let templateOffsetX = 0;
        let templateOffsetY = 0;
        let templateMovementEnabled = false;
        let templateOpacity = 0.5; // Добавить эту строку

        // Цветовая палитра
        const colorPalette = [
            '#ffffff', '#000000', '#ff0000', '#00ff00', '#0000ff', 
            '#ffff00', '#ff00ff', '#00ffff', '#ffa500', '#800080',
            '#ffc0cb', '#a52a2a', '#808080', '#964b00', '#add8e6'
        ];

        // Сохранение состояния при загрузке
        function loadPixelPaintState() {
            const saved = localStorage.getItem('pixelPaintState');
            if (saved) {
                const state = JSON.parse(saved);
                pixelCanvases = state.pixelCanvases || [];
                currentCanvasIndex = state.currentCanvasIndex || 0;
                
                // Обрезаем массив если сохранено больше холстов чем лимит
                if (pixelCanvases.length > MAX_CANVASES) {
                    pixelCanvases = pixelCanvases.slice(0, MAX_CANVASES);
                    currentCanvasIndex = Math.min(currentCanvasIndex, MAX_CANVASES - 1);
                }
                
                // Добавляем имена если их нет (для обратной совместимости)
                pixelCanvases.forEach((canvas, index) => {
                    if (!canvas.name) {
                        canvas.name = `Холст ${index + 1}`;
                    }
                });
                
                if (pixelCanvases.length === 0) {
                    pixelCanvases = [{
                        pixels: {},
                        template: null,
                        name: 'Холст 1'
                    }];
                }
            } else {
                pixelCanvases = [{
                    pixels: {},
                    template: null,
                    name: 'Холст 1'
                }];
            }
        }

        // Сохранение состояния при выходе
        function savePixelPaintState() {
            const state = {
                pixelCanvases: pixelCanvases,
                currentCanvasIndex: currentCanvasIndex
            };
            localStorage.setItem('pixelPaintState', JSON.stringify(state));
        }

        // Инициализация PixelPaint
        function initPixelPaint() {
            loadPixelPaintState();
            
            // Инициализируем цветовой пикер
            document.getElementById('colorPreview').style.backgroundColor = currentColor;
            
            // Инициализируем текущий холст
            initCurrentCanvas();
            
            // Обновляем вкладки
            updateCanvasTabs();

            // Инициализация инструментов замены цвета
            document.getElementById('replaceFromColor').style.backgroundColor = replaceFromColor;
            document.getElementById('replaceToColorPreview').style.backgroundColor = replaceToColor;
            document.getElementById('pipetteBtn').addEventListener('click', activateReplacePipette);

            // Добавляем обработчик клавиши Escape
            document.addEventListener('keydown', handleEscapeKey);
            
            updateToolInfo();
            updateDeselectButton(); // Инициализируем кнопку отмены выделения
        }

        // Инициализация текущего холста
        function initCurrentCanvas() {
            const pixelArea = document.getElementById('pixelArea');
            pixelArea.innerHTML = `
                <div class="pixel-grid"></div>
                <div class="template-overlay" id="templateOverlay"></div>
            `;
            
            // Добавляем обработчики событий
            setupPixelAreaEvents();
            
            // Восстанавливаем пиксели для текущего холста
            renderPixels();
            
            // Восстанавливаем шаблон если есть
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            if (currentCanvas.template) {
                loadTemplateFromData(currentCanvas.template);
            }
        }

        // Настройка обработчиков событий для области рисования
        function setupPixelAreaEvents() {
            const pixelArea = document.getElementById('pixelArea');
            
            pixelArea.onmousedown = function(e) {
                const coords = getPixelCoordinates(e);
                if (!coords) return;
                
                const [x, y] = coords;
                
                if (e.button === 0) { // ЛКМ
                    if (e.altKey || isPipetteMode) {
                        pickColor(e);
                        if (isPipetteMode) {
                            e.preventDefault();
                            return;
                        }
                    } else {
                        if (currentTool === 'selection') {
                            startSelection(x, y);
                        } else if (currentTool === 'fill') {
                            // Для заливки сохраняем состояние сразу
                            saveActionState('fill', {
                                fillData: { x, y, color: currentColor }
                            });
                            fillArea(x, y);
                        } else if (currentTool === 'brush') {
                            // Для кисти мазок начнется при первом движении
                            startDrawing(e);
                        }
                    }
                } else if (e.button === 2) { // ПКМ
                    if (currentTool === 'brush') {
                        startErasing(e);
                    }
                }
                e.preventDefault();
            };
            
            pixelArea.onmousemove = function(e) {
                const coords = getPixelCoordinates(e);
                if (!coords) return;
                
                const [x, y] = coords;
                
                if (currentTool === 'selection' && isSelecting) {
                    updateSelection(x, y);
                } else if (currentTool === 'brush') {
                    if (isDrawing) {
                        drawWithBrush(x, y);
                    } else if (isErasing) {
                        erasePixel(e);
                    }
                }
            };
            
            pixelArea.onmouseup = function(e) {
                if (e.button === 0) {
                    if (currentTool === 'selection') {
                        endSelection();
                    } else if (currentTool === 'brush') {
                        stopDrawing();
                        // Завершаем мазок при отпускании ЛКМ
                        endStroke();
                    }
                } else if (e.button === 2) {
                    if (currentTool === 'brush') {
                        stopErasing();
                    }
                }
            };
            
            pixelArea.onmouseleave = function() {
                if (currentTool === 'brush') {
                    stopDrawing();
                    stopErasing();
                    // Завершаем мазок при выходе за пределы холста
                    if (isStrokeActive) {
                        endStroke();
                    }
                }
                if (currentTool === 'selection') {
                    isSelecting = false;
                }
            };
            
            pixelArea.oncontextmenu = function(e) {
                e.preventDefault();
            };
        }
        // Функции для рисования
        function startDrawing(e) {
            isDrawing = true;
            continuousMode = e.shiftKey;
            // Мазок начнется при первом движении, не здесь
        }

        function stopDrawing() {
            isDrawing = false;
            continuousMode = false;
        }

        function drawPixel(e) {
            if (!isDrawing && !continuousMode) return;
            
            const coords = getPixelCoordinates(e);
            if (!coords) return;
            
            const [x, y] = coords;
            
            if (currentTool === 'brush') {
                drawWithBrush(x, y);
            }
        }

        // Функции для стирания
        function startErasing(e) {
            isErasing = true;
            erasePixel(e);
        }

        function stopErasing() {
            isErasing = false;
        }

        function erasePixel(e) {
            if (!isErasing) return;
            
            const coords = getPixelCoordinates(e);
            if (!coords) return;
            
            const [x, y] = coords;
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            const pixelKey = `${x},${y}`;
            
            if (currentCanvas.pixels[pixelKey]) {
                delete currentCanvas.pixels[pixelKey];
                removePixel(x, y);
                
                playRemoveSound();
            }
        }

        // Получение координат пикселя
        function getPixelCoordinates(e) {
            const rect = e.currentTarget.getBoundingClientRect();
            const x = Math.floor((e.clientX - rect.left) / 10);
            const y = Math.floor((e.clientY - rect.top) / 10);
            
            if (x < 0 || x >= 64 || y < 0 || y >= 40) return null;
            
            return [x, y];
        }

        // Выбор цвета из пикера
        function selectColorFromPicker(color) {
            currentColor = color;
            document.getElementById('colorPreview').style.backgroundColor = color;
            // Добавляем в недавние цвета при выборе из пикера
            addToRecentColors(color);
        }

        // Функции рендеринга
        function renderPixels() {
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            Object.keys(currentCanvas.pixels).forEach(key => {
                const [x, y] = key.split(',').map(Number);
                renderPixel(x, y, currentCanvas.pixels[key]);
            });
        }

        function renderPixel(x, y, color) {
            const pixelId = `pixel-${x}-${y}`;
            let pixel = document.getElementById(pixelId);
            
            if (!pixel) {
                pixel = document.createElement('div');
                pixel.id = pixelId;
                pixel.className = 'pixel';
                pixel.style.left = (x * 10) + 'px';
                pixel.style.top = (y * 10) + 'px';
                document.getElementById('pixelArea').appendChild(pixel);
            }
            
            pixel.style.backgroundColor = color;
        }

        function removePixel(x, y) {
            const pixelId = `pixel-${x}-${y}`;
            const pixel = document.getElementById(pixelId);
            if (pixel) {
                pixel.remove();
            }
        }

        // Пипетка
        function pickColor(e) {
            const coords = getPixelCoordinates(e);
            if (!coords) return;
            
            const [x, y] = coords;
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            const pixelKey = `${x},${y}`;
            
            if (isPipetteMode && pipetteForReplace) {
                // Режим пипетки для замены цвета
                pickColorForReplace(e);
                return;
            }
            
            if (currentCanvas.pixels[pixelKey]) {
                const pickedColor = currentCanvas.pixels[pixelKey];
                selectColorFromPicker(pickedColor);
                // Добавляем выбранный цвет в недавние
                addToRecentColors(pickedColor);
                playClickSound();
            }
            
            // Если был активирован режим пипетки (обычный), деактивируем его
            if (isPipetteMode) {
                deactivatePipetteMode();
            }
        }

        // Управление холстами
        function clearCanvas() {
            if (confirm('Очистить текущий холст?')) {
                saveActionState('clear');
                
                const currentCanvas = pixelCanvases[currentCanvasIndex];
                currentCanvas.pixels = {};
                
                document.querySelectorAll('.pixel').forEach(pixel => pixel.remove());
                playRemoveSound();
            }
        }
        // Константа для лимита холстов
        const MAX_CANVASES = 5;

        function addNewCanvas() {
            if (pixelCanvases.length >= MAX_CANVASES) {
                alert(`Достигнут лимит холстов! Максимальное количество: ${MAX_CANVASES}`);
                playCancelSound();
                return;
            }
            
            const newCanvas = {
                pixels: {},
                template: null,
                name: `Холст ${pixelCanvases.length + 1}` // Добавляем имя по умолчанию
            };
            
            pixelCanvases.push(newCanvas);
            currentCanvasIndex = pixelCanvases.length - 1;
            
            initCurrentCanvas();
            updateCanvasTabs();
            hideTemplateControls();
            playClickSound();
        }

        function switchCanvas(index) {
            if (index >= 0 && index < pixelCanvases.length) {
                // Сохраняем текущее состояние перед переключением
                savePixelPaintState();

                currentCanvasIndex = index;
                initCurrentCanvas();
                updateCanvasTabs();
                
                undoStack = [];
                redoStack = [];
                updateUndoRedoButtons();

                // Показываем/скрываем контролы шаблона
                const currentCanvas = pixelCanvases[currentCanvasIndex];
                if (currentCanvas.template) {
                    showTemplateControls();
                } else {
                    hideTemplateControls();
                }
                
                playClickSound();
            }
        }

        function updateCanvasTabs() {
            const counter = document.getElementById('canvasCounter');
            const buttonsContainer = document.getElementById('canvasButtons');
            const limitInfo = document.getElementById('limitInfo');
            
            // Обновляем счетчик
            counter.textContent = `Холсты: ${pixelCanvases.length}/${MAX_CANVASES}`;
            
            // Меняем цвет счетчика при достижении лимита
            if (pixelCanvases.length >= MAX_CANVASES) {
                counter.style.color = '#e74c3c';
                counter.style.background = 'rgba(231, 76, 60, 0.1)';
            } else {
                counter.style.color = '#f0f0f0';
                counter.style.background = 'rgba(70, 70, 70, 0.6)';
            }
            
            // Очищаем кнопки
            buttonsContainer.innerHTML = '';
            
            // Создаем кнопки для каждого холста с возможностью переименования
            pixelCanvases.forEach((canvas, index) => {
                const tabContainer = document.createElement('div');
                tabContainer.className = `canvas-tab ${index === currentCanvasIndex ? 'active' : ''}`;
                tabContainer.style.position = 'relative';
                tabContainer.style.padding = '10px 30px 10px 15px'; // Добавляем место для кнопки
                
                const tabText = document.createElement('span');
                tabText.textContent = canvas.name;
                
                // Кнопка переименования (появляется при наведении)
                const renameBtn = document.createElement('button');
                renameBtn.className = 'rename-btn';
                renameBtn.innerHTML = '✎';
                renameBtn.title = 'Переименовать';
                renameBtn.onclick = (e) => {
                    e.stopPropagation();
                    startRenamingCanvas(index, tabContainer, tabText);
                };
                
                tabContainer.appendChild(tabText);
                tabContainer.appendChild(renameBtn);
                tabContainer.onclick = () => switchCanvas(index);
                
                buttonsContainer.appendChild(tabContainer);
            });
            
            // Показываем/скрываем предупреждение о лимите
            if (pixelCanvases.length >= MAX_CANVASES) {
                limitInfo.style.display = 'block';
            } else {
                limitInfo.style.display = 'none';
            }
        }

        // Функция начала переименования холста
        function startRenamingCanvas(canvasIndex, tabContainer, tabText) {
            const currentName = pixelCanvases[canvasIndex].name;
            
            // Создаем input для редактирования
            const input = document.createElement('input');
            input.type = 'text';
            input.className = 'rename-input';
            input.value = currentName;
            input.maxLength = 20;
            input.style.width = '100%';
            
            // Сохраняем оригинальный текст
            const originalText = tabText.textContent;
            
            // Заменяем текст на input
            tabText.style.display = 'none';
            tabContainer.insertBefore(input, tabText);
            tabContainer.classList.add('editing');
            
            // Фокусируем и выделяем текст
            input.focus();
            input.select();
            
            // Обработчик сохранения по Enter или потере фокуса
            const finishRenaming = () => {
                const newName = input.value.trim();
                
                // Удаляем input
                input.remove();
                tabText.style.display = 'inline';
                tabContainer.classList.remove('editing');
                
                if (newName && newName !== currentName) {
                    pixelCanvases[canvasIndex].name = newName;
                    tabText.textContent = newName;
                    playClickSound();
                } else {
                    tabText.textContent = originalText;
                }
            };
            
            input.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    finishRenaming();
                }
            });
            
            input.addEventListener('blur', finishRenaming);
            
            // Обработчик отмены по Escape
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    input.remove();
                    tabText.style.display = 'inline';
                    tabText.textContent = originalText;
                    tabContainer.classList.remove('editing');
                    playCancelSound();
                }
            });
        }

        // Сохранение рисунка
        function saveDrawing() {
            const canvas = document.createElement('canvas');
            canvas.width = 640;
            canvas.height = 400;
            const ctx = canvas.getContext('2d');
            
            // Заливаем фон
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, 640, 400);
            
            // Рисуем пиксели
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            Object.keys(currentCanvas.pixels).forEach(key => {
                const [x, y] = key.split(',').map(Number);
                ctx.fillStyle = currentCanvas.pixels[key];
                ctx.fillRect(x * 10, y * 10, 10, 10);
            });
            
            // Создаем ссылку для скачивания
            const link = document.createElement('a');
            link.download = `pixelart-${new Date().getTime()}.png`;
            link.href = canvas.toDataURL();
            link.click();
            
            playClickSound();
        }
        // Управление шаблоном
        function loadTemplate(file) {
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                const img = new Image();
                img.onload = function() {
                    const currentCanvas = pixelCanvases[currentCanvasIndex];
                    currentCanvas.template = {
                        src: e.target.result,
                        width: img.width,
                        height: img.height
                    };
                    
                    loadTemplateFromData(currentCanvas.template);
                    showTemplateControls();
                    playClickSound();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function loadTemplateFromData(templateData) {
            templateImage = new Image();
            templateImage.onload = function() {
                renderTemplate();
            };
            templateImage.src = templateData.src;
            
            templateScale = 1;
            templateOffsetX = 0;
            templateOffsetY = 0;
            templateMovementEnabled = false;
            
            document.getElementById('templateScale').value = 1;
            updateMovementButtons();
        }

        function renderTemplate() {
            const overlay = document.getElementById('templateOverlay');
            overlay.innerHTML = '';
            
            const scaledWidth = templateImage.width * templateScale;
            const scaledHeight = templateImage.height * templateScale;
            
            const canvas = document.createElement('canvas');
            canvas.width = scaledWidth;
            canvas.height = scaledHeight;
            const ctx = canvas.getContext('2d');
            
            ctx.drawImage(templateImage, 0, 0, scaledWidth, scaledHeight);
            
            // Создаем pixel-art overlay
            const pixelSize = 10;
            for (let y = 0; y < scaledHeight; y += 2) {
                for (let x = 0; x < scaledWidth; x += 2) {
                    const pixelData = ctx.getImageData(x, y, 1, 1).data;
                    if (pixelData[3] > 0) { // Проверяем альфа-канал
                        const color = `rgb(${pixelData[0]}, ${pixelData[1]}, ${pixelData[2]})`;
                        
                        const pixel = document.createElement('div');
                        pixel.className = 'pixel';
                        pixel.style.left = (x/2 + templateOffsetX) * pixelSize + 'px';
                        pixel.style.top = (y/2 + templateOffsetY) * pixelSize + 'px';
                        pixel.style.backgroundColor = color;
                        pixel.style.opacity = templateOpacity.toString();
                        pixel.style.pointerEvents = 'none';
                        
                        overlay.appendChild(pixel);
                    }
                }
            }
        }

        function updateTemplateScale(scale) {
            templateScale = parseFloat(scale);
            if (templateImage) {
                renderTemplate();
            }
        }

        function updateTemplateOpacity(opacity) {
            templateOpacity = parseFloat(opacity);
            if (templateImage) {
                renderTemplate();
            }
        }

        function moveTemplate(dx, dy) {
            if (!templateMovementEnabled) return;
            
            templateOffsetX += dx;
            templateOffsetY += dy;
            
            if (templateImage) {
                renderTemplate();
            }
        }

        function showTemplateControls() {
            document.getElementById('templateControls').style.display = 'block';
        }

        function hideTemplateControls() {
            document.getElementById('templateControls').style.display = 'none';
        }

        // Обновляем функцию скрытия модального окна для сохранения состояния
        const originalHideModalWithSound = hideModalWithSound;
        hideModalWithSound = function(modalId) {
            if (modalId === 'pixelGame') {
                savePixelPaintState();
                // Сохраняем недавние цвета
                saveRecentColors();
                // Удаляем обработчик горячих клавиш
                document.removeEventListener('keydown', handleKeyPress);
                // Удаляем обработчик Escape
                document.removeEventListener('keydown', handleEscapeKey);
            }
            originalHideModalWithSound(modalId);
        };

        // Удаление текущего холста
        function deleteCurrentCanvas() {
            if (pixelCanvases.length <= 1) {
                alert('Нельзя удалить единственный холст!');
                return;
            }
            
            if (confirm('Удалить текущий холст? Это действие нельзя отменить.')) {
                pixelCanvases.splice(currentCanvasIndex, 1);
                currentCanvasIndex = Math.max(0, currentCanvasIndex - 1);
                
                initCurrentCanvas();
                updateCanvasTabs();
                
                const currentCanvas = pixelCanvases[currentCanvasIndex];
                if (!currentCanvas.template) {
                    hideTemplateControls();
                }
                
                playRemoveSound();
            }
        }

        // Удаление шаблона
        function removeTemplate() {
            if (confirm('Удалить шаблон с текущего холста?')) {
                const currentCanvas = pixelCanvases[currentCanvasIndex];
                currentCanvas.template = null;
                templateImage = null;
                
                const overlay = document.getElementById('templateOverlay');
                overlay.innerHTML = '';
                
                hideTemplateControls();
                playRemoveSound();
            }
        }

        // Переключение видимости шаблона
        function toggleTemplateVisibility() {
            const overlay = document.getElementById('templateOverlay');
            if (overlay.style.display === 'none') {
                overlay.style.display = 'block';
                playClickSound();
            } else {
                overlay.style.display = 'none';
                playCancelSound();
            }
        }

        // Обновить функцию перемещения шаблона (убрать проверку на enabled)
        function moveTemplate(dx, dy) {
            templateOffsetX += dx;
            templateOffsetY += dy;
            
            if (templateImage) {
                renderTemplate();
            }
        }

        // Обновить функцию загрузки шаблона (убрать включение перемещения)
        function loadTemplateFromData(templateData) {
            templateImage = new Image();
            templateImage.onload = function() {
                renderTemplate();
            };
            templateImage.src = templateData.src;
            
            templateScale = 1;
            templateOffsetX = 0;
            templateOffsetY = 0;
            
            document.getElementById('templateScale').value = 1;
            document.getElementById('templateOpacity').value = 0.5; // Добавить эту строку
        }

        // Функции для инструментов
        function selectTool(tool) {
            if (isPipetteMode) {
                deactivatePipetteMode();
            }
            currentTool = tool;
            
            // Обновляем активные кнопки
            document.querySelectorAll('.tool-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.getElementById(tool + 'Tool').classList.add('active');
            
            // Показываем/скрываем контролы инструментов
            document.querySelectorAll('.tool-controls').forEach(controls => {
                controls.classList.remove('active');
            });
            
            if (tool === 'brush') {
                document.getElementById('brushControls').classList.add('active');
                // При переключении на кисть сбрасываем выделение
                if (hasSelection()) {
                    deselectArea();
                }
            } else if (tool === 'fill') {
                document.getElementById('fillControls').classList.add('active');
                // При переключении на заливку сбрасываем выделение
                if (hasSelection()) {
                    deselectArea();
                }
            } else if (tool === 'selection') {
                document.getElementById('selectionControls').classList.add('active');
                // Обновляем предпросмотр при выборе инструмента выделения
                setTimeout(() => {
                    updateDeselectButton(); // Обновляем состояние кнопки
                    if (hasSelection()) {
                        previewReplaceSelection();
                    }
                }, 100);
            }
            
            // Убираем выделение при смене инструмента (кроме selection)
            if (tool !== 'selection') {
                clearSelectionVisual();
                // Сбрасываем координаты выделения
                selectionStartX = selectionEndX = selectionStartY = selectionEndY = 0;
            }
            
            playClickSound();
        }

        function updateBrushSize(size) {
            brushSize = parseInt(size);
            document.getElementById('brushSizeValue').textContent = size;
        }

        function drawWithBrush(x, y) {
            // Если мазок еще не начат, начинаем его
            if (!isStrokeActive) {
                startStroke();
            }
            
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            const radius = Math.floor(brushSize / 2);
            
            // Рисуем сферу (круг) пикселей и добавляем в текущий мазок
            for (let dy = -radius; dy <= radius; dy++) {
                for (let dx = -radius; dx <= radius; dx++) {
                    // Проверяем, находится ли пиксель внутри круга
                    if (dx * dx + dy * dy <= radius * radius) {
                        const pixelX = x + dx;
                        const pixelY = y + dy;
                        
                        // Проверяем границы холста
                        if (pixelX >= 0 && pixelX < 64 && pixelY >= 0 && pixelY < 40) {
                            addPixelToStroke(pixelX, pixelY, currentColor);
                        }
                    }
                }
            }
            
            // Добавляем цвет в недавние после рисования
            addToRecentColors(currentColor);
            playPaintSound();
        }

        // Функция заливки области
        function fillArea(x, y) {
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            const targetColor = currentCanvas.pixels[`${x},${y}`];
            
            // Если кликнули на уже закрашенный пиксель, выходим
            if (targetColor === currentColor) return;
            
            // Используем алгоритм заливки с помощью очереди
            const queue = [[x, y]];
            const visited = new Set();
            
            while (queue.length > 0) {
                const [currentX, currentY] = queue.shift();
                const key = `${currentX},${currentY}`;
                
                // Проверяем границы и посещенные пиксели
                if (currentX < 0 || currentX >= 64 || currentY < 0 || currentY >= 40) continue;
                if (visited.has(key)) continue;
                
                const pixelColor = currentCanvas.pixels[key];
                
                // Заливаем только если цвет совпадает с исходным или пиксель пустой
                if (pixelColor === targetColor || (pixelColor === undefined && targetColor === undefined)) {
                    currentCanvas.pixels[key] = currentColor;
                    renderPixel(currentX, currentY, currentColor);
                    visited.add(key);
                    
                    // Добавляем соседние пиксели
                    queue.push([currentX + 1, currentY]);
                    queue.push([currentX - 1, currentY]);
                    queue.push([currentX, currentY + 1]);
                    queue.push([currentX, currentY - 1]);
                }
            }
            
            // Добавляем цвет в недавние после заливки
            addToRecentColors(currentColor);
            playPaintSound();
        }

        // Функции для выделения
        function startSelection(x, y) {
            isSelecting = true;
            selectionStartX = x;
            selectionStartY = y;
            selectionEndX = x;
            selectionEndY = y;
            updateSelectionVisual();
            updateDeselectButton(); // Обновляем кнопку
        }

        function updateSelection(x, y) {
            if (!isSelecting) return;
            selectionEndX = x;
            selectionEndY = y;
            updateSelectionVisual();
            updateDeselectButton(); // Обновляем кнопку в реальном времени
            
            // Обновляем предпросмотр замены при изменении выделения
            if (document.getElementById('selectionControls').classList.contains('active')) {
                previewReplaceSelection();
            }
        }

        function endSelection() {
            if (!isSelecting) return;
            isSelecting = false;
            
            // Нормализуем координаты выделения
            const startX = Math.min(selectionStartX, selectionEndX);
            const startY = Math.min(selectionStartY, selectionEndY);
            const endX = Math.max(selectionStartX, selectionEndX);
            const endY = Math.max(selectionStartY, selectionEndY);
            
            selectionStartX = startX;
            selectionStartY = startY;
            selectionEndX = endX;
            selectionEndY = endY;
            
            updateDeselectButton(); // Обновляем кнопку
            
            // Обновляем предпросмотр замены
            if (document.getElementById('selectionControls').classList.contains('active')) {
                previewReplaceSelection();
            }
        }

        function updateSelectionVisual() {
            clearSelectionVisual();
            
            const startX = Math.min(selectionStartX, selectionEndX);
            const startY = Math.min(selectionStartY, selectionEndY);
            const endX = Math.max(selectionStartX, selectionEndX);
            const endY = Math.max(selectionStartY, selectionEndY);
            
            const width = (endX - startX + 1) * 10;
            const height = (endY - startY + 1) * 10;
            
            const selectionArea = document.createElement('div');
            selectionArea.className = 'selection-area';
            selectionArea.style.left = (startX * 10) + 'px';
            selectionArea.style.top = (startY * 10) + 'px';
            selectionArea.style.width = width + 'px';
            selectionArea.style.height = height + 'px';
            
            document.getElementById('pixelArea').appendChild(selectionArea);
        }

        function clearSelectionVisual() {
            const existingSelection = document.querySelector('.selection-area');
            if (existingSelection) {
                existingSelection.remove();
            }
            updateDeselectButton(); // Обновляем кнопку при очистке визуального выделения
        }

        function clearSelection() {
            if (confirm('Очистить выделенную область?')) {
                saveActionState('selection_action', {
                    selectionData: {
                        action: 'clear',
                        bounds: {
                            startX: Math.min(selectionStartX, selectionEndX),
                            startY: Math.min(selectionStartY, selectionEndY),
                            endX: Math.max(selectionStartX, selectionEndX),
                            endY: Math.max(selectionStartY, selectionEndY)
                        }
                    }
                });
                
                const currentCanvas = pixelCanvases[currentCanvasIndex];
                const startX = Math.min(selectionStartX, selectionEndX);
                const startY = Math.min(selectionStartY, selectionEndY);
                const endX = Math.max(selectionStartX, selectionEndX);
                const endY = Math.max(selectionStartY, selectionEndY);
                
                for (let y = startY; y <= endY; y++) {
                    for (let x = startX; x <= endX; x++) {
                        const pixelKey = `${x},${y}`;
                        if (currentCanvas.pixels[pixelKey]) {
                            delete currentCanvas.pixels[pixelKey];
                            removePixel(x, y);
                        }
                    }
                }
                
                playRemoveSound();
            }
        }

        function fillSelection() {
            saveActionState('selection_action', {
                selectionData: {
                    action: 'fill',
                    bounds: {
                        startX: Math.min(selectionStartX, selectionEndX),
                        startY: Math.min(selectionStartY, selectionEndY),
                        endX: Math.max(selectionStartX, selectionEndX),
                        endY: Math.max(selectionStartY, selectionEndY)
                    },
                    color: currentColor
                }
            });
            
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            const startX = Math.min(selectionStartX, selectionEndX);
            const startY = Math.min(selectionStartY, selectionEndY);
            const endX = Math.max(selectionStartX, selectionEndX);
            const endY = Math.max(selectionStartY, selectionEndY);
            
            for (let y = startY; y <= endY; y++) {
                for (let x = startX; x <= endX; x++) {
                    const pixelKey = `${x},${y}`;
                    currentCanvas.pixels[pixelKey] = currentColor;
                    renderPixel(x, y, currentColor);
                }
            }
            
            // Добавляем цвет в недавние после заливки выделения
            addToRecentColors(currentColor);
            playPaintSound();
        }

        function updateReplaceToColor(color) {
            replaceToColor = color;
            document.getElementById('replaceToColorPreview').style.backgroundColor = color;
            
            // Обновляем предпросмотр при изменении цвета
            if (selectionStartX !== selectionEndX || selectionStartY !== selectionEndY) {
                previewReplaceSelection();
            }
        }

        function replaceSelectionColor() {
            saveActionState('selection_action', {
                selectionData: {
                    action: 'replace_color',
                    bounds: {
                        startX: Math.min(selectionStartX, selectionEndX),
                        startY: Math.min(selectionStartY, selectionEndY),
                        endX: Math.max(selectionStartX, selectionEndX),
                        endY: Math.max(selectionStartY, selectionEndY)
                    },
                    fromColor: replaceFromColor,
                    toColor: replaceToColor
                }
            });
            
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            const startX = Math.min(selectionStartX, selectionEndX);
            const startY = Math.min(selectionStartY, selectionEndY);
            const endX = Math.max(selectionStartX, selectionEndX);
            const endY = Math.max(selectionStartY, selectionEndY);
            
            let replacedCount = 0;
            
            for (let y = startY; y <= endY; y++) {
                for (let x = startX; x <= endX; x++) {
                    const pixelKey = `${x},${y}`;
                    if (currentCanvas.pixels[pixelKey] === replaceFromColor) {
                        currentCanvas.pixels[pixelKey] = replaceToColor;
                        renderPixel(x, y, replaceToColor);
                        replacedCount++;
                    }
                }
            }
            
            if (replacedCount > 0) {
                playClickSound();
            } else {
                playCancelSound();
                alert('В выделенной области не найдено пикселей выбранного цвета для замены.');
            }
        }

        // Функция для активации режима пипетки для замены цвета
        function activateReplacePipette() {
            isPipetteMode = true;
            pipetteForReplace = true;
            document.getElementById('pixelArea').classList.add('pipette-mode');
            document.getElementById('pipetteBtn').style.background = 'linear-gradient(135deg, #7c7c7c 0%, #616161 100%)';
            document.getElementById('pipetteBtn').style.borderColor = '#f7dc6f';
            document.getElementById('pipetteBtn').innerHTML = '🖍️ Пипетка';
            
            playClickSound();

            // Временно меняем описание для режима пипетки
            document.getElementById('toolDescription').textContent = 
                "Кликните на цвет на холсте для выбора цвета замены (или на пустую область для прозрачного фона)";
        }

        // Функция для выбора цвета замены с помощью пипетки
        function pickColorForReplace(e) {
            if (!isPipetteMode || !pipetteForReplace) return;
            
            const coords = getPixelCoordinates(e);
            if (!coords) return;
            
            const [x, y] = coords;
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            const pixelKey = `${x},${y}`;
            
            // Если кликнули на пустую область - устанавливаем прозрачный фон
            if (!currentCanvas.pixels[pixelKey]) {
                replaceFromColor = undefined; // Помечаем как прозрачный
                document.getElementById('replaceFromColor').style.backgroundColor = '#1a1a1a'; // Темный фон
                document.getElementById('replaceFromColor').style.backgroundImage = 
                    'linear-gradient(45deg, #333 25%, transparent 25%), linear-gradient(-45deg, #333 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #333 75%), linear-gradient(-45deg, transparent 75%, #333 75%)';
                document.getElementById('replaceFromColor').style.backgroundSize = '4px 4px';
                document.getElementById('replaceFromColor').style.backgroundPosition = '0 0, 0 2px, 2px -2px, -2px 0px';
            } else {
                replaceFromColor = currentCanvas.pixels[pixelKey];
                document.getElementById('replaceFromColor').style.backgroundColor = replaceFromColor;
                document.getElementById('replaceFromColor').style.backgroundImage = 'none';
            }
            
            // Выходим из режима пипетки
            deactivatePipetteMode();
            
            // Обновляем предпросмотр
            if (selectionStartX !== selectionEndX || selectionStartY !== selectionEndY) {
                previewReplaceSelection();
            }
            
            playClickSound();
        }

        // Функция деактивации режима пипетки
        function deactivatePipetteMode() {
            isPipetteMode = false;
            pipetteForReplace = false;
            document.getElementById('pixelArea').classList.remove('pipette-mode');
            document.getElementById('pipetteBtn').style.background = 'linear-gradient(135deg, #606060 0%, #505050 100%)';
            document.getElementById('pipetteBtn').style.borderColor = '#a0a0a0';
            // Возвращаем обычное описание инструмента
            updateToolInfo();
        }

        // Обновить функцию pickColor для работы с двумя режимами пипетки
        function pickColor(e) {
            const coords = getPixelCoordinates(e);
            if (!coords) return;
            
            const [x, y] = coords;
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            const pixelKey = `${x},${y}`;
            
            if (isPipetteMode && pipetteForReplace) {
                // Режим пипетки для замены цвета
                pickColorForReplace(e);
                return;
            }
            
            if (currentCanvas.pixels[pixelKey]) {
                selectColorFromPicker(currentCanvas.pixels[pixelKey]);
                playClickSound();
            }
            
            // Если был активирован режим пипетки (обычный), деактивируем его
            if (isPipetteMode) {
                deactivatePipetteMode();
            }
        }

        // Функция обновления информационной панели
        function updateToolInfo() {
            document.getElementById('currentToolName').textContent = toolNames[currentTool];
            document.getElementById('toolDescription').textContent = toolDescriptions[currentTool];
        }

        // Функция сохранения состояния для undo
        function saveState() {
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            const state = JSON.parse(JSON.stringify(currentCanvas.pixels));
            
            undoStack.push(state);
            redoStack = []; // Очищаем стек повтора при новом действии
            
            // Ограничиваем размер стека
            if (undoStack.length > MAX_UNDO_STEPS) {
                undoStack.shift();
            }
            
            updateUndoRedoButtons();
        }

        // Функция начала мазка
        function startStroke() {
            if (isStrokeActive) return;
            
            isStrokeActive = true;
            currentStrokePixels.clear();
            
            // Сохраняем состояние до начала мазка
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            const stateBeforeStroke = JSON.parse(JSON.stringify(currentCanvas.pixels));
            undoStack.push({
                type: 'stroke_start',
                state: stateBeforeStroke
            });
        }

        // Функция добавления пикселя в текущий мазок
        function addPixelToStroke(x, y, color) {
            if (!isStrokeActive) return;
            
            const pixelKey = `${x},${y}`;
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            
            // Сохраняем оригинальный цвет пикселя (если он был изменен ранее в этом мазке)
            if (!currentStrokePixels.has(pixelKey)) {
                currentStrokePixels.set(pixelKey, currentCanvas.pixels[pixelKey]);
            }
            
            // Устанавливаем новый цвет
            currentCanvas.pixels[pixelKey] = color;
            renderPixel(x, y, color);
        }

        // Функция завершения мазка
        function endStroke() {
            if (!isStrokeActive) return;
            
            // Сохраняем изменения мазка в undo stack
            if (currentStrokePixels.size > 0) {
                const strokeData = {
                    type: 'stroke',
                    pixels: Array.from(currentStrokePixels.entries()),
                    finalState: JSON.parse(JSON.stringify(pixelCanvases[currentCanvasIndex].pixels))
                };
                
                // Заменяем начало мазка на полные данные мазка
                if (undoStack.length > 0 && undoStack[undoStack.length - 1].type === 'stroke_start') {
                    undoStack.pop(); // Удаляем маркер начала
                }
                
                undoStack.push(strokeData);
                redoStack = []; // Очищаем стек повтора
                
                // Ограничиваем размер стека
                if (undoStack.length > MAX_UNDO_STEPS) {
                    undoStack.shift();
                }
            } else {
                // Если мазок пустой, удаляем маркер начала
                if (undoStack.length > 0 && undoStack[undoStack.length - 1].type === 'stroke_start') {
                    undoStack.pop();
                }
            }
            
            isStrokeActive = false;
            currentStrokePixels.clear();
            updateUndoRedoButtons();
        }

        // Функция отмены действия
        function undoAction() {
            if (undoStack.length === 0) return;
            
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            const currentState = JSON.parse(JSON.stringify(currentCanvas.pixels));
            
            let action = undoStack.pop();
            
            if (action.type === 'stroke') {
                // Восстанавливаем состояние до мазка
                redoStack.push({
                    type: 'stroke',
                    pixels: action.pixels,
                    finalState: currentState
                });
                
                // Восстанавливаем оригинальные цвета пикселей
                action.pixels.forEach(([pixelKey, originalColor]) => {
                    if (originalColor === undefined) {
                        delete currentCanvas.pixels[pixelKey];
                        removePixel(...pixelKey.split(',').map(Number));
                    } else {
                        currentCanvas.pixels[pixelKey] = originalColor;
                        renderPixel(...pixelKey.split(',').map(Number), originalColor);
                    }
                });
            } else if (action.type === 'fill') {
                // Обработка заливки
                redoStack.push({
                    type: 'fill',
                    state: currentState,
                    fillData: action.fillData
                });
                
                currentCanvas.pixels = JSON.parse(JSON.stringify(action.state));
                redrawCanvas();
            } else if (action.type === 'clear') {
                // Обработка очистки
                redoStack.push({
                    type: 'clear',
                    state: currentState
                });
                
                currentCanvas.pixels = JSON.parse(JSON.stringify(action.state));
                redrawCanvas();
            } else if (action.type === 'selection_action') {
                // Обработка действий с выделением
                redoStack.push({
                    type: 'selection_action',
                    state: currentState,
                    selectionData: action.selectionData
                });
                
                currentCanvas.pixels = JSON.parse(JSON.stringify(action.state));
                redrawCanvas();
            }
            
            updateUndoRedoButtons();
            playClickSound();
        }

        // Функция повтора действия
        function redoAction() {
            if (redoStack.length === 0) return;
            
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            const currentState = JSON.parse(JSON.stringify(currentCanvas.pixels));
            
            let action = redoStack.pop();
            
            if (action.type === 'stroke') {
                // Восстанавливаем мазок
                undoStack.push({
                    type: 'stroke',
                    pixels: action.pixels.map(([key, originalColor]) => [key, currentCanvas.pixels[key]]),
                    finalState: currentState
                });
                
                // Применяем мазок
                currentCanvas.pixels = JSON.parse(JSON.stringify(action.finalState));
                redrawCanvas();
            } else if (action.type === 'fill') {
                // Восстанавливаем заливку
                undoStack.push({
                    type: 'fill',
                    state: currentState,
                    fillData: action.fillData
                });
                
                currentCanvas.pixels = JSON.parse(JSON.stringify(action.state));
                redrawCanvas();
            } else if (action.type === 'clear') {
                // Восстанавливаем очистку
                undoStack.push({
                    type: 'clear',
                    state: currentState
                });
                
                currentCanvas.pixels = JSON.parse(JSON.stringify(action.state));
                redrawCanvas();
            } else if (action.type === 'selection_action') {
                // Восстанавливаем действие с выделением
                undoStack.push({
                    type: 'selection_action',
                    state: currentState,
                    selectionData: action.selectionData
                });
                
                currentCanvas.pixels = JSON.parse(JSON.stringify(action.state));
                redrawCanvas();
            }
            
            updateUndoRedoButtons();
            playClickSound();
        }

        // Функция сохранения состояния для других действий (заливка, очистка и т.д.)
        function saveActionState(actionType, data = null) {
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            const state = JSON.parse(JSON.stringify(currentCanvas.pixels));
            
            undoStack.push({
                type: actionType,
                state: state,
                ...data
            });
            
            redoStack = []; // Очищаем стек повтора
            
            // Ограничиваем размер стека
            if (undoStack.length > MAX_UNDO_STEPS) {
                undoStack.shift();
            }
            
            updateUndoRedoButtons();
        }

        // Функция перерисовки холста
        function redrawCanvas() {
            // Очищаем текущие пиксели
            document.querySelectorAll('.pixel').forEach(pixel => pixel.remove());
            
            // Перерисовываем все пиксели из текущего состояния
            renderPixels();
        }

        // Функция обновления состояния кнопок undo/redo
        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = undoStack.length === 0;
            document.getElementById('redoBtn').disabled = redoStack.length === 0;
        }

        // Функция обработки горячих клавиш
        function handleKeyPress(e) {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z' && !e.shiftKey) {
                    e.preventDefault();
                    undoAction();
                } else if (e.key === 'y' || (e.key === 'z' && e.shiftKey)) {
                    e.preventDefault();
                    redoAction();
                }
            }
        }

        // Функция добавления цвета в недавние
        function addToRecentColors(color) {
            // Удаляем цвет если он уже есть в списке
            const existingIndex = recentColors.indexOf(color);
            if (existingIndex !== -1) {
                recentColors.splice(existingIndex, 1);
            }
            
            // Добавляем цвет в начало списка
            recentColors.unshift(color);
            
            // Ограничиваем размер списка
            if (recentColors.length > MAX_RECENT_COLORS) {
                recentColors.pop();
            }
            
            // Обновляем отображение
            updateRecentColorsDisplay();
        }

        // Функция обновления отображения недавних цветов
        function updateRecentColorsDisplay() {
            const recentColorsContainer = document.getElementById('recentColors');
            recentColorsContainer.innerHTML = '';
            
            // Создаем элементы для каждого недавнего цвета
            for (let i = 0; i < MAX_RECENT_COLORS; i++) {
                const colorItem = document.createElement('div');
                
                if (i < recentColors.length) {
                    // Заполненный цвет
                    colorItem.className = 'recent-color-item';
                    colorItem.style.backgroundColor = recentColors[i];
                    colorItem.title = `Цвет: ${recentColors[i]}`;
                    colorItem.onclick = () => selectRecentColor(recentColors[i]);
                } else {
                    // Пустой слот
                    colorItem.className = 'recent-color-item empty';
                    colorItem.title = 'Пусто';
                }
                
                recentColorsContainer.appendChild(colorItem);
            }
        }

        // Функция выбора цвета из недавних
        function selectRecentColor(color) {
            currentColor = color;
            document.getElementById('colorPreview').style.backgroundColor = color;
            // Перемещаем выбранный цвет в начало списка
            addToRecentColors(color);
            playClickSound();
        }

        // Функция загрузки недавних цветов из localStorage
        function loadRecentColors() {
            const saved = localStorage.getItem('pixelPaintRecentColors');
            if (saved) {
                recentColors = JSON.parse(saved);
                updateRecentColorsDisplay();
            }
        }

        // Функция сохранения недавних цветов в localStorage
        function saveRecentColors() {
            localStorage.setItem('pixelPaintRecentColors', JSON.stringify(recentColors));
        }

        // Функция переключения чекбокса прозрачного фона
        function toggleTransparentBg() {
            replaceTransparentBg = document.getElementById('transparentBgCheckbox').checked;
            playClickSound();
        }

        // Функция замены цвета в выделенной области (обновленная)
        function replaceSelectionColor() {
            const startX = Math.min(selectionStartX, selectionEndX);
            const startY = Math.min(selectionStartY, selectionEndY);
            const endX = Math.max(selectionStartX, selectionEndX);
            const endY = Math.max(selectionStartY, selectionEndY);
            
            // Сохраняем действие для undo
            saveActionState('selection_action', {
                selectionData: {
                    action: 'replace_color',
                    bounds: { startX, startY, endX, endY },
                    fromColor: replaceFromColor,
                    toColor: replaceToColor,
                    replaceTransparent: replaceTransparentBg
                }
            });
            
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            let replacedCount = 0;
            
            for (let y = startY; y <= endY; y++) {
                for (let x = startX; x <= endX; x++) {
                    const pixelKey = `${x},${y}`;
                    const currentPixelColor = currentCanvas.pixels[pixelKey];
                    
                    let shouldReplace = false;
                    
                    // Проверяем условия замены
                    if (replaceTransparentBg) {
                        // Заменяем либо указанный цвет, либо прозрачные участки
                        shouldReplace = currentPixelColor === replaceFromColor || 
                                    currentPixelColor === undefined;
                    } else {
                        // Заменяем только указанный цвет
                        shouldReplace = currentPixelColor === replaceFromColor;
                    }
                    
                    if (shouldReplace) {
                        // Если это прозрачный участок и включена замена прозрачности
                        if (currentPixelColor === undefined && replaceTransparentBg) {
                            currentCanvas.pixels[pixelKey] = replaceToColor;
                            renderPixel(x, y, replaceToColor);
                        } 
                        // Если это цвет для замены
                        else if (currentPixelColor === replaceFromColor) {
                            currentCanvas.pixels[pixelKey] = replaceToColor;
                            renderPixel(x, y, replaceToColor);
                        }
                        replacedCount++;
                    }
                }
            }
            
            if (replacedCount > 0) {
                playClickSound();
                // Показываем статистику замены
                showReplaceStats(replacedCount, startX, startY, endX, endY);
            } else {
                playCancelSound();
                alert('В выделенной области не найдено подходящих пикселей для замены.');
            }
        }

        // Функция показа статистики замены
        function showReplaceStats(replacedCount, startX, startY, endX, endY) {
            const width = endX - startX + 1;
            const height = endY - startY + 1;
            const totalPixels = width * height;
            const percentage = Math.round((replacedCount / totalPixels) * 100);
            
            // Создаем временное сообщение
            const statsMessage = document.createElement('div');
            statsMessage.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(80, 80, 80, 0.95);
                border: 2px solid #f7dc6f;
                border-radius: 10px;
                padding: 15px;
                color: #f0f0f0;
                font-family: 'Courier New', monospace;
                font-size: 14px;
                z-index: 10000;
                text-align: center;
                box-shadow: 0 0 20px rgba(247, 220, 111, 0.3);
            `;
            
            // Автоматически скрываем через 2 секунды
            setTimeout(() => {
                statsMessage.style.opacity = '0';
                statsMessage.style.transition = 'opacity 0.5s ease';
                setTimeout(() => {
                    if (statsMessage.parentNode) {
                        statsMessage.parentNode.removeChild(statsMessage);
                    }
                }, 500);
            }, 2000);
        }

        // Функция предпросмотра замены (опционально)
        function previewReplaceSelection() {
            const startX = Math.min(selectionStartX, selectionEndX);
            const startY = Math.min(selectionStartY, selectionEndY);
            const endX = Math.max(selectionStartX, selectionEndX);
            const endY = Math.max(selectionStartY, selectionEndY);
            
            const currentCanvas = pixelCanvases[currentCanvasIndex];
            let affectedPixels = 0;
            
            for (let y = startY; y <= endY; y++) {
                for (let x = startX; x <= endX; x++) {
                    const pixelKey = `${x},${y}`;
                    const currentPixelColor = currentCanvas.pixels[pixelKey];
                    
                    let shouldReplace = false;
                    
                    if (replaceTransparentBg) {
                        shouldReplace = currentPixelColor === replaceFromColor || 
                                    currentPixelColor === undefined;
                    } else {
                        shouldReplace = currentPixelColor === replaceFromColor;
                    }
                    
                    if (shouldReplace) {
                        affectedPixels++;
                    }
                }
            }
            
            const width = endX - startX + 1;
            const height = endY - startY + 1;
            const totalPixels = width * height;
            const percentage = Math.round((affectedPixels / totalPixels) * 100);
            
            // Обновляем описание инструмента для показа предпросмотра
            document.getElementById('toolDescription').textContent = 
                `Будет заменено: ${affectedPixels} пикселей (${percentage}% области)`;
            
            return affectedPixels;
        }

        // Функция отмены выделения
        function deselectArea() {
            if (!hasSelection()) return;
            
            // Сбрасываем координаты выделения
            selectionStartX = 0;
            selectionStartY = 0;
            selectionEndX = 0;
            selectionEndY = 0;
            isSelecting = false;
            
            // Убираем визуальное выделение
            clearSelectionVisual();
            
            // Обновляем состояние кнопки
            updateDeselectButton();
            
            // Сбрасываем предпросмотр замены
            document.getElementById('toolDescription').textContent = toolDescriptions.selection;
            
            playClickSound();
        }

        // Функция проверки наличия активного выделения
        function hasSelection() {
            return selectionStartX !== selectionEndX || selectionStartY !== selectionEndY;
        }

        // Функция обновления состояния кнопки отмены выделения
        function updateDeselectButton() {
            const deselectBtn = document.getElementById('deselectBtn');
            const hasActiveSelection = hasSelection();
            
            deselectBtn.disabled = !hasActiveSelection;
            
            if (hasActiveSelection) {
                const width = Math.abs(selectionEndX - selectionStartX) + 1;
                const height = Math.abs(selectionEndY - selectionStartY) + 1;
                deselectBtn.innerHTML = `❌ Отменить выделение (${width}×${height})`;
            } else {
                deselectBtn.innerHTML = '❌ Отменить выделение';
            }
        }

        // Функция отмены выделения по клавише Escape
        function handleEscapeKey(e) {
            if (e.key === 'Escape' && currentTool === 'selection' && hasSelection()) {
                deselectArea();
                e.preventDefault();
            }
        }

        // Секретные функции
        // Позиционируем секретную кнопку в случайном свободном углу
        function positionSecretButton() {
            // Создаем массив всех возможных углов
            const allCorners = [...corners];
            
            // Выбираем случайный угол
            const randomIndex = Math.floor(Math.random() * allCorners.length);
            
            // Устанавливаем позицию кнопки
            Object.assign(secretButton.style, allCorners[randomIndex]);
            
            // Всегда делаем кнопку невидимой, но она будет появляться при наведении
            secretButton.style.opacity = '0';
            secretButton.style.pointerEvents = 'auto';
        }
        
        // Обработчик клика на секретную кнопку
        function handleSecretButtonClick() {
            // Если это пятое нажатие или больше - показываем вопрос о коде
            if (secretClickCount >= 4) {
                showCodeQuestion();
                return;
            }
            
            // Плавно останавливаем музыку перед показом секретных текстов
            fadeOutMusic(() => {
                secretClickCount++;
                
                // На четвертом нажатии делаем кнопку видимой
                if (secretClickCount === 4) {
                    secretButton.classList.add('visible');
                }
                
                // Запускаем секретную последовательность
                startSecretSequence();
            });
        }
        
        function startSecretSequence() {
            // Скрываем кнопку (но она все равно будет появляться при наведении)
            secretButton.style.opacity = '0';
            secretButton.style.pointerEvents = 'none';
            
            // Ждем 2 секунды
            setTimeout(() => {
                // Плавно затемняем экран
                darkOverlay.style.display = 'block';
                setTimeout(() => {
                    darkOverlay.classList.add('active');
                }, 10);
                
                // Плавно запускаем музыку
                const musicVolume = document.getElementById('musicVolume').value / 100;
                secretMusic.volume = 0;
                secretMusic.play();
                fadeAudio(secretMusic, 0, musicVolume, 1000);
                
                // Показываем первый текст
                currentTextIndex = 0;
                showSecretText();
            }, 2000);
        }
        
        function showSecretText() {
            const texts = secretTexts[secretClickCount - 1];
            
            if (currentTextIndex < texts.length) {
                secretText.textContent = texts[currentTextIndex];
                secretText.style.display = 'block';
                
                // Плавно показываем текст
                setTimeout(() => {
                    secretText.classList.add('visible');
                }, 10);
                
                // Добавляем обработчик клика для перехода к следующему текста
                secretClickHandler = handleSecretClick;
                document.addEventListener('click', secretClickHandler);
            }
        }
        
        function handleSecretClick() {
            const texts = secretTexts[secretClickCount - 1];
            
            // Плавно скрываем текущий текст
            secretText.classList.remove('visible');
            
            setTimeout(() => {
                currentTextIndex++;
                
                if (currentTextIndex < texts.length) {
                    // Показываем следующий текст
                    secretText.textContent = texts[currentTextIndex];
                    setTimeout(() => {
                        secretText.classList.add('visible');
                    }, 10);
                } else {
                    // Завершаем последовательность
                    endSecretSequence();
                }
            }, 500);
        }
        
        function endSecretSequence() {
            // Убираем обработчик клика
            if (secretClickHandler) {
                document.removeEventListener('click', secretClickHandler);
                secretClickHandler = null;
            }
            
            // Плавно скрываем текст
            secretText.classList.remove('visible');
            
            setTimeout(() => {
                secretText.style.display = 'none';
                
                // Плавно убираем затемнение
                darkOverlay.classList.remove('active');
                
                // Плавно останавливаем секретную музыку
                fadeAudio(secretMusic, secretMusic.volume, 0, 1000, () => {
                    secretMusic.pause();
                    secretMusic.currentTime = 0;
                    
                    // Возобновляем обычную музыку только если она играла до секрета
                    setTimeout(() => {
                        if (wasMusicPlayingBeforeSecret) {
                            fadeInMusic();
                        }
                    }, 500);
                });
                
                setTimeout(() => {
                    darkOverlay.style.display = 'none';
                    
                    // После третьего нажатия делаем кнопку видимой
                    if (secretClickCount === 4) {
                        secretButton.classList.add('visible');
                    }
                    
                    // Перемещаем кнопку в новый свободный угол
                    positionSecretButton();
                }, 1000);
            }, 500);
        }
        
        // Функция для показа вопроса о коде
        function showCodeQuestion() {
            // Плавно останавливаем музыку перед показом вопроса
            fadeOutMusic(() => {
                // Плавно затемняем экран
                darkOverlay.style.display = 'block';
                setTimeout(() => {
                    darkOverlay.classList.add('active');
                }, 10);
                
                // Плавно запускаем секретную музыку
                const musicVolume = document.getElementById('musicVolume').value / 100;
                secretMusic.volume = 0;
                secretMusic.play();
                fadeAudio(secretMusic, 0, musicVolume, 1000);
                
                // Показываем вопрос
                secretText.textContent = "[Ты нашёл код?]";
                secretText.style.display = 'block';
                setTimeout(() => {
                    secretText.classList.add('visible');
                    
                    // Добавляем обработчик клика для показа кнопок Да/Нет
                    document.addEventListener('click', showYesNoButtonsAfterText);
                }, 10);
            });
        }

        // Новая функция для показа кнопок после клика по тексту
        function showYesNoButtonsAfterText() {
            // Убираем обработчик клика
            document.removeEventListener('click', showYesNoButtonsAfterText);
            
            // Показываем активные кнопки Да/Нет
            yesNoContainer.style.display = 'flex';
            yesNoContainer.style.pointerEvents = 'auto';
            setTimeout(() => {
                yesNoContainer.classList.add('visible');
            }, 10);
        }


        // Функция для показа кнопок Да/Нет
        function showYesNoButtons() {
            // Убираем обработчик клика
            document.removeEventListener('click', showYesNoButtons);
            
            // Убедимся, что кнопки активны
            yesButton.style.pointerEvents = 'auto';
            noButton.style.pointerEvents = 'auto';
            yesButton.style.opacity = '1';
            noButton.style.opacity = '1';
        }
        
        // Обработчики для кнопок Да/Нет
        yesButton.addEventListener('click', function() {
            playClickSound();
            // Плавно меняем текст
            secretText.classList.remove('visible');
            setTimeout(() => {
                secretText.textContent = "[Тогда введи его...]";
                setTimeout(() => {
                    secretText.classList.add('visible');
                    
                    // Через 2 секунды показываем браузерный prompt
                    setTimeout(() => {
                        submitCode(); // Вызываем функцию с prompt
                    }, 2000);
                }, 10);
            }, 500);
            
            // Скрываем кнопки Да/Нет
            yesNoContainer.classList.remove('visible');
            setTimeout(() => {
                yesNoContainer.style.display = 'none';
                yesNoContainer.style.pointerEvents = 'none';
            }, 500);
        });


        noButton.addEventListener('click', function() {
            playClickSound();
            // Плавно меняем текст
            secretText.classList.remove('visible');
            setTimeout(() => {
                secretText.textContent = "[Тогда иди и найди его.]";
                setTimeout(() => {
                    secretText.classList.add('visible');
                    
                    // Добавляем обработчик клика для закрытия с возобновлением музыки
                    document.addEventListener('click', closeSecretSequenceWithMusicRestore);
                }, 10);
            }, 500);
            
            // Скрываем кнопки Да/Нет
            yesNoContainer.classList.remove('visible');
            setTimeout(() => {
                yesNoContainer.style.display = 'none';
            }, 500);
        });
        
        // Функция для закрытия секретной последовательности
        function closeSecretSequence() {
            // Убираем все обработчики клика
            document.removeEventListener('click', closeSecretSequence);
            document.removeEventListener('click', showYesNoButtonsAfterText);
            
            // Плавно скрываем текст
            secretText.classList.remove('visible');
            
            // Плавно убираем затемнение
            darkOverlay.classList.remove('active');
            
            // Плавно скрываем кнопки Да/Нет
            yesNoContainer.classList.remove('visible');
            
            // Плавно останавливаем секретную музыку
            fadeAudio(secretMusic, secretMusic.volume, 0, 1000, () => {
                secretMusic.pause();
                secretMusic.currentTime = 0;
                
                // Возобновляем обычную музыку только если она играла до секрета
                setTimeout(() => {
                    if (wasMusicPlayingBeforeSecret) {
                        fadeInMusic();
                    }
                }, 500);
            });
            
            // Через 1 секунду полностью скрываем все элементы
            setTimeout(() => {
                secretText.style.display = 'none';
                darkOverlay.style.display = 'none';
                yesNoContainer.style.display = 'none';
                yesNoContainer.style.pointerEvents = 'none';
                
                // Перемещаем кнопку в новый свободный угол
                positionSecretButton();
            }, 1000);
        }

        function closeSecretSequenceWithMusicRestore() {
            // Убираем все обработчики клика
            document.removeEventListener('click', closeSecretSequenceWithMusicRestore);
            document.removeEventListener('click', showYesNoButtonsAfterText);
            
            // Плавно скрываем текст
            secretText.classList.remove('visible');
            
            // Плавно убираем затемнение
            darkOverlay.classList.remove('active');
            
            // Плавно скрываем кнопки Да/Нет
            yesNoContainer.classList.remove('visible');
            
            // Плавно останавливаем секретную музыку
            fadeAudio(secretMusic, secretMusic.volume, 0, 1000, () => {
                secretMusic.pause();
                secretMusic.currentTime = 0;
                
                // Возобновляем обычную музыку только если она играла до секрета
                setTimeout(() => {
                    if (wasMusicPlayingBeforeSecret) {
                        fadeInMusic();
                    }
                }, 500);
            });
            
            // Через 1 секунду полностью скрываем все элементы
            setTimeout(() => {
                secretText.style.display = 'none';
                darkOverlay.style.display = 'none';
                yesNoContainer.style.display = 'none';
                yesNoContainer.style.pointerEvents = 'none';
                
                // Перемещаем кнопку в новый свободный угол
                positionSecretButton();
            }, 1000);
        }
        
        // НОВАЯ функция для отправки кода через prompt
        function submitCode() {
            // Используем стандартный prompt браузера
            const input = prompt("Введите секретный код:");
            
            if (input === "2016") {
                // Правильный код - перенаправляем
                window.location.href = 'after_the_code.html';
            } else if (input !== null) {
                // Неправильный код - показываем сообщение и снова открываем prompt
                alert("Ты ввёл неверный код. Ты точно его нашёл?");
                // Рекурсивно вызываем функцию снова
                setTimeout(submitCode, 100); // Небольшая задержка чтобы alert успел закрыться
            } else {
                // Пользователь нажал "Отмена" - возобновляем музыку (если играла) и закрываем
                setTimeout(() => {
                    if (wasMusicPlayingBeforeSecret) {
                        fadeInMusic();
                    }
                    closeSecretSequence();
                }, 100);
            }
        }
        
        // Функция для плавного изменения громкости аудио
        function fadeAudio(audio, fromVolume, toVolume, duration, callback) {
            const startTime = Date.now();
            const interval = 50;
            const steps = duration / interval;
            const stepSize = (toVolume - fromVolume) / steps;
            let currentStep = 0;
            
            function updateVolume() {
                currentStep++;
                const elapsed = Date.now() - startTime;
                if (elapsed < duration) {
                    audio.volume = fromVolume + (stepSize * currentStep);
                    setTimeout(updateVolume, interval);
                } else {
                    audio.volume = toVolume;
                    if (callback) callback();
                }
            }
            
            updateVolume();
        }

        // Показать ошибку 404
        function show404() {
            playClickSound();
            document.getElementById('errorModal').style.display = 'flex';
        }

        // Скрыть ошибку 404
        function hide404() {
            playCancelSound();
            document.getElementById('errorModal').style.display = 'none';
        }

        // Инициализация
        document.addEventListener('DOMContentLoaded', function() {
            document.querySelectorAll('.page').forEach(page => {
                page.style.display = 'none';
            });
            document.getElementById('main').style.display = 'block';
            
            // Устанавливаем начальное состояние - лампочка включена, дневной фон
            document.getElementById('lampImage').src = 'sun_on.png';
            document.body.classList.add('light-theme');
            isLampOn = true;
            
            // Добавляем обработчик промахов для AimLabs
            document.getElementById('gameArea').addEventListener('click', function(e) {
                if (aimGameActive && e.target === this) {
                    misses++;
                    document.getElementById('misses').textContent = misses;
                }
            });

            // Добавляем обработчики звуков для всех кнопок
            document.querySelectorAll('button, .side-btn, .game-btn, .bet-field, .target').forEach(button => {
                button.addEventListener('mouseover', playHoverSound);
            });

            // Инициализация секретной кнопки
            positionSecretButton();
            secretButton.addEventListener('click', handleSecretButtonClick);
            
            yesNoContainer.style.display = 'none';
            yesNoContainer.style.pointerEvents = 'none';
            yesNoContainer.classList.remove('visible');

            // Обработчик завершения музыки для повторного воспроизведения
            secretMusic.addEventListener('ended', function() {
                this.currentTime = 0;
                this.play();
            });

            // Устанавливаем начальную громкость
            updateVolume();

            initMusicPlayer();

            // Инициализация PixelPaint при загрузке модального окна
            document.getElementById('pixelGame').addEventListener('click', function(e) {
                if (e.target === this) {
                    initPixelPaint();
                }
            });

        });

        // Функция для эффекта ошибок на кнопках
        function startErrorTextEffect() {
            if (!interfaceLocked) return;
            
            // Получаем ВСЕ элементы для эффекта ошибок
            const sideButtons = document.querySelectorAll('.side-btn');
            const gameLabels = document.querySelectorAll('.game-label');
            const volumeLabels = document.querySelectorAll('.volume-label');

            
            // Объединяем все элементы в один массив
            const allElements = [...sideButtons, ...gameLabels, ...volumeLabels];
            
            // Функция для показа ошибок на группе элементов
            function showErrorsOnGroup() {
                // Скрываем ошибки со всех элементов
                allElements.forEach(element => {
                    if (element.dataset.originalText) {
                        element.textContent = element.dataset.originalText;
                    }
                    // Возвращаем оригинальные стили
                    if (element.classList.contains('side-btn')) {
                        if (element.classList.contains('main-btn')) {
                            element.style.background = 'linear-gradient(135deg, #7c7c7c 0%, #616161 100%)';
                        } else {
                            element.style.background = 'linear-gradient(135deg, #606060 0%, #1a1a1a 100%)';
                        }
                    }
                    element.style.color = element.classList.contains('volume-label') ? '#d0d0d0' : '#f0f0f0';
                });
                
                // Выбираем случайную группу от 1 до 3 элементов
                const elementsToChange = getRandomElements(allElements, 2 + Math.floor(Math.random() * 5));
                
                // Показываем ошибки на выбранной группе
                elementsToChange.forEach(element => {
                    // Сохраняем оригинальный текст если еще не сохранен
                    if (!element.dataset.originalText) {
                        element.dataset.originalText = element.textContent;
                    }
                    
                    // Массив возможных ошибок
                    const errorTexts = ['[ERROR]', '[FATAL ERROR]', '[NULL]'];
                    const randomError = errorTexts[Math.floor(Math.random() * errorTexts.length)];
                    
                    // Заменяем текст на случайную ошибку
                    element.textContent = randomError;
                    element.style.color = '#a0a0a0'; // Серый цвет вместо красного
                });
                
                // Через 5 секунд переключаем на следующую группу
                setTimeout(showErrorsOnGroup, 7000);
            }
            
            // Запускаем цикл ошибок
            showErrorsOnGroup();
        }

        // Вспомогательная функция для выбора случайных элементов
        function getRandomElements(array, count) {
            const shuffled = [...array].sort(() => 0.5 - Math.random());
            return shuffled.slice(0, count);
        }

    </script>
</body>
</html>
